

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>SSICovRef &mdash; pyOMA  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pyOMA
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../classes/preprocessing.html">Pre-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes/oma.html">Operational Modal Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes/postprocessing.html">Post-processing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyOMA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>SSICovRef</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for SSICovRef</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Based on previous works by Andrei Udrea 2014 and Volkmar Zabel 2015</span>
<span class="sd">Modified and Extended by Simon Marwitz 2015-2018</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> 
<span class="kn">import</span> <span class="nn">scipy.optimize</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">PreprocessingTools</span> <span class="kn">import</span> <span class="n">PreprocessData</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plot</span>
<span class="kn">from</span> <span class="nn">numpy.linalg.linalg</span> <span class="kn">import</span> <span class="n">LinAlgError</span>

<div class="viewcode-block" id="ModalBase"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.ModalBase">[docs]</a><span class="k">class</span> <span class="nc">ModalBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Base Class from which all other modal analysis classes should be inherited</span>
<span class="sd">    * provides commonly used functions s.t. these don&#39;t have to be copied to each class</span>
<span class="sd">    * object type checks in post-processing functions can check for </span>
<span class="sd">    modal base instead of each possible modal analysis class</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prep_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">prep_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span> <span class="o">=</span><span class="n">prep_data</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="kc">None</span>
        
<div class="viewcode-block" id="ModalBase.remove_conjugates"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.ModalBase.remove_conjugates">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">remove_conjugates</span><span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">,</span> <span class="n">eigvec_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inds_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        finds conjugates: :math:`\\lambda_i = \\overline{\\lambda_j} for i \\neq j`</span>
<span class="sd">        </span>
<span class="sd">        unstable poles i.e. negatively damped poles :math:`[ln(|\lambda|)&lt;0]: |\lambda_i|&gt; 1`</span>
<span class="sd">        overdamped poles :math:`[atan(Im/Re)=0]` i.e. real poles: :math:`Im(\lambda_i)==0`  </span>
<span class="sd">        imaginary poles i.e. nyquist frequency: :math:`Re(\lambda_i)==0`</span>
<span class="sd">        </span>
<span class="sd">        keeps the second occurance of a conjugate pair (usually the one with the negative imaginary part)</span>
<span class="sd">        </span>
<span class="sd">        eigvec_l.shape = [order+1, order+1]</span>
<span class="sd">        eigval.shape = [order+1,1]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">num_val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">eigval</span><span class="p">)</span>
        <span class="n">conj_indices</span><span class="o">=</span><span class="n">deque</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_val</span><span class="p">):</span>
            <span class="n">this_val</span><span class="o">=</span><span class="n">eigval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">this_conj_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">this_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this_val</span> <span class="o">==</span> <span class="n">this_conj_val</span><span class="p">:</span> <span class="c1">#remove overdamped poles  i.e. real eigvals</span>
                <span class="n">conj_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">this_val</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="c1">#remove negatively damped poles i.e. unstable poles</span>
                <span class="n">conj_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_val</span><span class="p">):</span> <span class="c1">#catches unordered conjugates but takes slightly longer</span>
                <span class="k">if</span> <span class="n">eigval</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_conj_val</span><span class="p">:</span>
                    <span class="n">conj_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="n">conj_indices</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_val</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">inds_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conj_indices</span>
        
        <span class="k">if</span> <span class="n">eigvec_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            
            <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
            <span class="n">eigval</span> <span class="o">=</span> <span class="n">eigval</span><span class="p">[</span><span class="n">conj_indices</span><span class="p">]</span>
    
            <span class="k">return</span> <span class="n">eigval</span><span class="p">,</span><span class="n">eigvec_r</span>      
        
        <span class="k">else</span><span class="p">:</span>             
            <span class="n">eigvec_l</span> <span class="o">=</span> <span class="n">eigvec_l</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
            <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
            <span class="n">eigval</span> <span class="o">=</span> <span class="n">eigval</span><span class="p">[</span><span class="n">conj_indices</span><span class="p">]</span>
    
            <span class="k">return</span> <span class="n">eigval</span><span class="p">,</span><span class="n">eigvec_l</span><span class="p">,</span><span class="n">eigvec_r</span>      </div>
    
<div class="viewcode-block" id="ModalBase.integrate_quantities"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.ModalBase.integrate_quantities">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">integrate_quantities</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">accel_channels</span><span class="p">,</span> <span class="n">velo_channels</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="c1"># input quantities = [a, v, d]</span>
        <span class="c1"># output quantities = [d, d, d]</span>
        <span class="c1"># converts amplitude and phase</span>
        <span class="c1">#                     phase + 180; magn / omega^2</span>
        
        <span class="n">vector</span><span class="p">[</span><span class="n">accel_channels</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>       <span class="o">/</span> <span class="p">(</span><span class="n">omega</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">#                    phase + 90; magn / omega</span>
        <span class="n">vector</span><span class="p">[</span><span class="n">velo_channels</span><span class="p">]</span> <span class="o">*=</span>  <span class="mi">1</span><span class="n">j</span>        <span class="o">/</span> <span class="n">omega</span>
        
        <span class="k">return</span> <span class="n">vector</span>   </div>
    
<div class="viewcode-block" id="ModalBase.rescale_mode_shape"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.ModalBase.rescale_mode_shape">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rescale_mode_shape</span><span class="p">(</span><span class="n">modeshape</span><span class="p">):</span>
        <span class="c1">#scaling of mode shape</span>
        <span class="n">modeshape</span> <span class="o">=</span> <span class="n">modeshape</span> <span class="o">/</span> <span class="n">modeshape</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">modeshape</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">modeshape</span> </div></div>
    
<div class="viewcode-block" id="BRSSICovRef"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef">[docs]</a><span class="k">class</span> <span class="nc">BRSSICovRef</span><span class="p">(</span><span class="n">ModalBase</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>    
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1">#             0         1           2         </span>
        <span class="c1">#self.state= [Toeplitz, State Mat., Modal Par.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span>  <span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span>    <span class="kc">False</span><span class="p">,</span>      <span class="kc">False</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toeplitz_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># compute_state_matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#self.V_T = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_contributions</span> <span class="o">=</span> <span class="kc">None</span>
            
<div class="viewcode-block" id="BRSSICovRef.init_from_config"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef.init_from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">init_from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">conf_file</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">conf_file</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">conf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Number of Block-Columns:&#39;</span>
            <span class="n">num_block_columns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Maximum Model Order:&#39;</span>
            <span class="n">max_model_order</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
            
        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">prep_data</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">build_toeplitz_cov</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_state_matrices</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_modal_params</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">ssi_object</span></div>
        
<div class="viewcode-block" id="BRSSICovRef.build_toeplitz_cov"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef.build_toeplitz_cov">[docs]</a>    <span class="k">def</span> <span class="nf">build_toeplitz_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Builds a Block-Toeplitz Matrix of Covariances with varying time lags</span>
<span class="sd">        ::</span>
<span class="sd">        </span>
<span class="sd">              &lt;-num_block_columns*num_ref_channels -&gt;  _</span>
<span class="sd">            [     R_i      R_i-1      ...      R_1    ]^</span>
<span class="sd">            [     R_i+1    R_i        ...      R_2    ]num_block_rows*num_analised_channels</span>
<span class="sd">            [     ...      ...        ...      ...    ]v</span>
<span class="sd">            [     R_2i-1   ...        ...      R_i    ]_</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_block_rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_block_rows</span><span class="o">=</span><span class="n">num_block_columns</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assembling toeplitz matrix using pre-computed correlation functions&#39;</span>
              <span class="s1">&#39; </span><span class="si">{}</span><span class="s1"> block-columns and </span><span class="si">{}</span><span class="s1"> block rows&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span><span class="o">=</span><span class="n">num_block_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span><span class="o">=</span><span class="n">num_block_rows</span>

        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span> 
        
        <span class="n">tau_max</span> <span class="o">=</span> <span class="n">num_block_rows</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">num_block_columns</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">tau_max</span> <span class="o">&lt;</span> <span class="n">tau_max</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">compute_correlation_matrices</span><span class="p">(</span><span class="n">tau_max</span><span class="p">)</span>
            
        <span class="n">corr_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">corr_matrix</span>
        
        <span class="n">Toeplitz_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_block_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">):</span>
                    
                    <span class="n">tau</span> <span class="o">=</span> <span class="n">num_block_columns</span><span class="o">+</span><span class="n">i</span><span class="o">-</span><span class="n">ii</span> <span class="o">+</span> <span class="n">shift</span>
                    <span class="n">this_block</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="p">[:,:,</span><span class="n">tau</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">begin_Toeplitz_row</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">num_analised_channels</span>
                    
                    <span class="n">Toeplitz_matrix</span><span class="p">[</span><span class="n">begin_Toeplitz_row</span><span class="p">:(</span><span class="n">begin_Toeplitz_row</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">),</span>
                                    <span class="n">ii</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">ii</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="o">+</span><span class="n">num_ref_channels</span><span class="p">)]</span> <span class="o">=</span> <span class="n">this_block</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">previous_Toeplitz_row</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span>
                <span class="n">this_block</span> <span class="o">=</span> <span class="n">Toeplitz_matrix</span><span class="p">[</span><span class="n">previous_Toeplitz_row</span><span class="p">:(</span><span class="n">previous_Toeplitz_row</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">),</span>
                                              <span class="mi">0</span><span class="p">:</span><span class="n">num_ref_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_columns</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">begin_Toeplitz_row</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">num_analised_channels</span>
                <span class="n">Toeplitz_matrix</span><span class="p">[</span><span class="n">begin_Toeplitz_row</span><span class="p">:(</span><span class="n">begin_Toeplitz_row</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">),</span>
                                 <span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">num_ref_channels</span> <span class="o">*</span> <span class="n">num_block_columns</span><span class="p">)]</span> <span class="o">=</span> <span class="n">this_block</span>
                <span class="n">tau</span> <span class="o">=</span> <span class="n">num_block_columns</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">shift</span>
                <span class="n">this_block</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="p">[:,:,</span><span class="n">tau</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">Toeplitz_matrix</span><span class="p">[</span><span class="n">begin_Toeplitz_row</span><span class="p">:(</span><span class="n">begin_Toeplitz_row</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">),</span>
                                 <span class="mi">0</span><span class="p">:</span><span class="n">num_ref_channels</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_block</span>
                                     
<span class="c1">#         import matplotlib.pyplot as plot</span>
<span class="c1">#             </span>
<span class="c1">#         for num_channel,ref_channel in enumerate(self.prep_data.ref_channels):</span>
<span class="c1">#             inds=([],[])</span>
<span class="c1">#             for i in range(num_block_columns):</span>
<span class="c1">#                 row = ref_channel</span>
<span class="c1">#                 col = (num_block_columns-i-1)*num_ref_channels+num_channel</span>
<span class="c1">#                 inds[0].append(row)</span>
<span class="c1">#                 inds[1].append(col)</span>
<span class="c1">#             for ii in range(1,num_block_rows):</span>
<span class="c1">#                 row = (ii)*num_analised_channels+ref_channel</span>
<span class="c1">#                 col = num_channel</span>
<span class="c1">#                 inds[0].append(row)</span>
<span class="c1">#                 inds[1].append(col)</span>
<span class="c1">#             means = Toeplitz_matrix[inds]</span>
<span class="c1">#             #print(means.shape, sigma_r[inds,inds].shape, len(inds))</span>
<span class="c1">#             #plot.errorbar(range(num_block_rows+num_block_rows-1), means, yerr=np.sqrt(sigma_r[inds,inds]))</span>
<span class="c1">#             #print(np.sqrt(sigma_r[inds,inds]))</span>
<span class="c1">#                   </span>
<span class="c1">#             #plot.plot(vec_R[inds,0])</span>
<span class="c1">#             #plot.plot(vec_R[inds,1])</span>
<span class="c1">#             plot.plot(range(1,num_block_columns+num_block_rows), means)</span>
<span class="c1">#         plot.show()</span>
        
        <span class="k">if</span> <span class="n">shift</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">toeplitz_matrix</span> <span class="o">=</span> <span class="n">Toeplitz_matrix</span>              
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Toeplitz_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span></div>
        
<div class="viewcode-block" id="BRSSICovRef.compute_state_matrices"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef.compute_state_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">compute_state_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_model_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>    
        
        <span class="n">Toeplitz_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toeplitz_matrix</span>        
        
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_model_order</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">Toeplitz_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>       
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_model_order</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span><span class="o">*</span><span class="n">Toeplitz_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing state matrices with pinv-based method, with maximum model order </span><span class="si">{}</span><span class="s1">...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">))</span>
        
        <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V_T</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">Toeplitz_matrix</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,:</span><span class="n">max_model_order</span><span class="p">]</span>
        <span class="n">V_T</span> <span class="o">=</span> <span class="n">V_T</span><span class="p">[:</span><span class="n">max_model_order</span><span class="p">,:]</span>     
        
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">U</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span> <span class="o">=</span> <span class="n">V_T</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span><span class="o">=</span><span class="n">max_model_order</span>   
               
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># previous modal params are invalid now</span></div>
    
<div class="viewcode-block" id="BRSSICovRef.compute_modal_params"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef.compute_modal_params">[docs]</a>    <span class="k">def</span> <span class="nf">compute_modal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_modes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">algo</span><span class="o">=</span><span class="s1">&#39;svd&#39;</span><span class="p">):</span> 
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        computes the modal parameters as indicated in Peeters 1999 and Döhler 2012</span>
<span class="sd">        only algorithm svd is optimized for multi-order computation</span>
<span class="sd">        max_modes i.e. crystal clear only works with algorithm svd</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">assert</span> <span class="n">algo</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;svd&#39;</span><span class="p">,</span><span class="s1">&#39;qr&#39;</span><span class="p">,</span><span class="s1">&#39;shift&#39;</span><span class="p">,</span><span class="s1">&#39;opti&#39;</span><span class="p">]</span>
        
        <span class="n">max_model_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>           
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span>
        <span class="n">accel_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">accel_channels</span>
        <span class="n">velo_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">velo_channels</span>
        <span class="c1">#merged_num_channels = self.merged_num_channels</span>
        <span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span>
        
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">V_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="n">S_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="n">max_model_order</span><span class="p">],</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">S_2_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="n">max_model_order</span><span class="p">],</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
        
        <span class="n">O</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">S_2</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S_2</span><span class="p">,</span> <span class="n">V_T</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">algo</span><span class="o">==</span><span class="s1">&#39;shift&#39;</span><span class="p">:</span>
            <span class="n">toeplitz_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_toeplitz_cov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing modal parameters...&#39;</span><span class="p">)</span>
    
        <span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">modal_damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">modal_contributions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>

        <span class="n">printsteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">):</span>                   
            <span class="k">while</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">printsteps</span><span class="p">:</span> 
                <span class="k">del</span> <span class="n">printsteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">this_modal_frequencies</span><span class="p">,</span> <span class="n">this_modal_damping</span><span class="p">,</span> <span class="n">this_mode_shapes</span><span class="p">,</span> <span class="n">this_eigenvalues</span><span class="p">,</span> <span class="n">this_modal_contributions</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">single_order_modal</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">algo</span><span class="p">,</span> <span class="n">max_modes</span><span class="p">,</span> <span class="n">plot_</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            
            <span class="n">modal_frequencies</span><span class="p">[</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">this_modal_frequencies</span>
            <span class="n">modal_damping</span><span class="p">[</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">this_modal_damping</span>
            <span class="n">mode_shapes</span><span class="p">[:,:</span><span class="n">order</span><span class="p">,</span><span class="n">order</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_mode_shapes</span>
            <span class="n">eigenvalues</span><span class="p">[</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">this_eigenvalues</span>
            <span class="n">modal_contributions</span><span class="p">[</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">this_modal_contributions</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">modal_frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="n">modal_damping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">mode_shapes</span>   
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">eigenvalues</span>   
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_contributions</span> <span class="o">=</span> <span class="n">modal_contributions</span>         

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span></div>
        
<div class="viewcode-block" id="BRSSICovRef.single_order_modal"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef.single_order_modal">[docs]</a>    <span class="k">def</span> <span class="nf">single_order_modal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">algo</span><span class="o">=</span><span class="s1">&#39;svd&#39;</span><span class="p">,</span> <span class="n">max_modes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corr_synth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> 
        
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span>
        <span class="n">accel_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">accel_channels</span>
        <span class="n">velo_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">velo_channels</span>
        <span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="n">tau_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">tau_max</span>
        
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,:</span><span class="n">order</span><span class="p">]</span>
        <span class="n">V_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span><span class="p">[:</span><span class="n">order</span><span class="p">,:]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="n">S_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="n">order</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">S_2_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="n">order</span><span class="p">],</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>

        
        <span class="n">O</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">S_2</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S_2</span><span class="p">,</span> <span class="n">V_T</span><span class="p">)</span>
        
        <span class="c1">#print(&#39;Computing modal parameters...&#39;)</span>
        
        <span class="n">corr_mats_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">num_ref_channels</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">)</span>
        <span class="n">corr_matrix_synth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">corr_mats_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        #From Brincker with participation factor for all channels:</span>
<span class="sd">        </span>
<span class="sd">        M = np.zeros((num_modes, tau_max*num_analised_channels), dtype=complex)</span>
<span class="sd">        H = np.zeros((num_analised_channels, num_ref_channels*tau_max))</span>
<span class="sd">        </span>
<span class="sd">        for tau in range(tau_max):</span>
<span class="sd">            M[:,tau*num_analised_channels:(tau+1)*num_analised_channels]=(mu_n**tau).dot(A.T)</span>
<span class="sd">            H[:,tau*num_ref_channels:(tau+1)*num_ref_channels]=corr_matrix[:,:,tau]</span>
<span class="sd">            </span>
<span class="sd">        Gamma = H.dot(np.linalg.pinv(M))/2/np.pi</span>
<span class="sd">        &#39;&#39;&#39;</span>
        


        
        <span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">))</span>
        <span class="n">modal_damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">))</span>
        <span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="n">modal_contributions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">))</span>
        <span class="n">corr_matrix_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">corr_matrix</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="n">Sigma_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">))</span>
        <span class="n">Sigma_synth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">))</span>
        <span class="n">Sigma_data_synth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
            
        <span class="n">On_up</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
        <span class="n">On_down</span> <span class="o">=</span> <span class="n">O</span><span class="p">[</span><span class="n">num_analised_channels</span><span class="p">:</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,:</span><span class="n">order</span><span class="p">]</span>

        <span class="n">On_up_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up</span><span class="p">)</span><span class="c1">#, rcond=1e-12)</span>
        
        <span class="k">if</span> <span class="n">algo</span><span class="o">==</span><span class="s1">&#39;svd&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_modes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">v_t</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">On_up</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">s</span><span class="p">[:</span><span class="n">max_modes</span><span class="p">]</span>
                <span class="n">On_up_i</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">v_t</span><span class="p">[:</span><span class="n">max_modes</span><span class="p">,:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">u</span><span class="p">[:,:</span><span class="n">max_modes</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">On_up_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up</span><span class="p">)</span><span class="c1">#, rcond=1e-12)</span>
            <span class="n">state_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">On_up_i</span><span class="p">,</span> <span class="n">On_down</span><span class="p">)</span>             
            
        <span class="k">elif</span> <span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
            <span class="n">Q</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">On_up</span><span class="p">)</span>
            <span class="n">S</span><span class="o">=</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">On_down</span><span class="p">)</span>
            <span class="n">state_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">algo</span><span class="o">==</span><span class="s1">&#39;shift&#39;</span><span class="p">:</span>
            <span class="n">state_matrix</span> <span class="o">=</span> <span class="n">S_2_inv</span><span class="p">[:</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">[:,:</span><span class="n">order</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">toeplitz_shift</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V_T</span><span class="p">[:</span><span class="n">order</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S_2_inv</span><span class="p">[:</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">])</span>
        
        <span class="n">C</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_analised_channels</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[:</span><span class="n">order</span><span class="p">,</span><span class="o">-</span><span class="n">num_ref_channels</span><span class="p">:]</span>
        
        <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">state_matrix</span><span class="p">)</span>
        
        <span class="n">G_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">eigvec_r</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eigvec_r</span><span class="p">)</span>
        
        <span class="n">conj_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_conjugates</span><span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">,</span><span class="n">inds_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plot_</span><span class="p">:</span>
            
            
            <span class="n">num_modes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">)</span>
            <span class="n">modelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_modes</span><span class="p">))</span>
            <span class="n">modelist</span><span class="o">=</span><span class="p">[</span><span class="mi">25</span><span class="p">,</span><span class="mi">26</span><span class="p">]</span>
            <span class="c1">#num_modes = 5</span>
            <span class="c1">#num_plots = int(np.ceil(np.sqrt(num_modes)))</span>
            <span class="c1">#num_plots=5</span>
            <span class="c1">#num_plots = num_modes</span>
            <span class="n">num_plots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modelist</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_plots</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;col&#39;</span><span class="p">,</span><span class="s1">&#39;none&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1">#axes= axes.flatten()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">):</span>
            
            <span class="n">lambda_i</span> <span class="o">=</span><span class="n">eigval</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            
            <span class="n">ident</span> <span class="o">=</span> <span class="n">eigval</span> <span class="o">==</span> <span class="n">lambda_i</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="n">ident</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1">#ident=np.diag(ident)</span>
                
            <span class="c1">#this_Lambda=np.diag(eigval).dot(ident)</span>
            <span class="n">this_eigval</span> <span class="o">=</span> <span class="n">eigval</span><span class="p">[</span><span class="n">ident</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">this_Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">eigval</span><span class="p">[</span><span class="n">ident</span><span class="p">])</span>
            
            
            <span class="n">this_Phi</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">[:,</span><span class="n">ident</span><span class="p">]</span>
            <span class="n">this_G_m</span> <span class="o">=</span> <span class="n">G_m</span><span class="p">[</span><span class="n">ident</span><span class="p">,:]</span>
            
            <span class="n">a_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">)))</span>
            <span class="n">b_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">))</span>
            <span class="n">freq_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sampling_rate</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">damping_i</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">ind</span><span class="p">])</span>
            <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            
            <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate_quantities</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">,</span> <span class="n">accel_channels</span><span class="p">,</span> <span class="n">velo_channels</span><span class="p">,</span> <span class="n">freq_i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  
   
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">))</span>
            <span class="n">s_ik</span> <span class="o">=</span> <span class="n">mode_shape_i</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">alpha_ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span>
            <span class="n">e_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">e_k</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
            <span class="c1">#print(f&#39;Scale factor {np.exp(-1j*alpha_ik)}&#39;)</span>
            <span class="n">mode_shape_i</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">alpha_ik</span><span class="p">)</span>
            
            <span class="n">modal_frequencies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">freq_i</span>
            <span class="n">modal_damping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">damping_i</span>
            <span class="n">mode_shapes</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">mode_shape_i</span>    
            <span class="n">eigenvalues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">lambda_i</span>
            
            <span class="k">if</span> <span class="n">plot_</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">modelist</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ip</span><span class="o">+=</span><span class="mi">1</span>
            

            
            <span class="k">if</span> <span class="n">corr_synth</span><span class="p">:</span>
                <span class="n">ft_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">tau_max</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">))</span>
                

                    
                <span class="n">this_corr_synth</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">corr_mats_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tau_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    
                    <span class="c1">#this_corr_synth[:,:,tau-1] = this_Phi.dot(this_Lambda**tau).dot(this_G_m).real</span>
                    <span class="n">this_corr_synth</span><span class="p">[:,:,</span><span class="n">tau</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_Phi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">this_G_m</span><span class="o">*</span><span class="p">(</span><span class="n">this_eigval</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="n">tau</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
                    
                <span class="n">this_corr_synth</span> <span class="o">=</span> <span class="n">this_corr_synth</span><span class="o">**</span><span class="mi">2</span>
                
                <span class="k">for</span> <span class="n">ref_channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span><span class="p">):</span>
                        <span class="n">Sigma_data_synth</span><span class="p">[</span><span class="n">ref_channel</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="o">+</span><span class="n">channel</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">corr_matrix_data</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">this_corr_synth</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                        <span class="c1">#if np.mean(Sigma_data_synth[ref_channel*num_analised_channels+channel, i])&lt;1e-11: continue</span>
                        
                        <span class="k">if</span> <span class="n">plot_</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">modelist</span><span class="p">:</span>
                                <span class="n">axes</span><span class="p">[</span><span class="n">ip</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">this_corr_synth</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:])</span>
                                <span class="n">ft_synth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">this_corr_synth</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">tau_max</span><span class="p">))</span>
                                <span class="n">axes</span><span class="p">[</span><span class="n">ip</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ft_freq</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ft_synth</span><span class="p">))</span>
                
                        
                <span class="n">corr_matrix_synth</span> <span class="o">+=</span><span class="n">this_corr_synth</span>
        
        <span class="k">if</span> <span class="n">plot_</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ref_channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span><span class="p">):</span>
                    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">corr_matrix_data</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:],</span><span class="n">alpha</span><span class="o">=.</span><span class="mi">5</span><span class="p">)</span>
              
                    <span class="n">ft_meas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">corr_matrix_data</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">tau_max</span><span class="p">))</span>
                    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ft_freq</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ft_meas</span><span class="p">),</span><span class="n">alpha</span><span class="o">=.</span><span class="mi">5</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">corr_synth</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ref_channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ref_channels</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_analised_channels</span><span class="p">):</span>
                    <span class="n">corr_data</span> <span class="o">=</span> <span class="n">corr_matrix_data</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:]</span>
                    <span class="n">corr_synth</span> <span class="o">=</span> <span class="n">corr_matrix_synth</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:]</span>
                    
                    <span class="n">Sigma_data</span><span class="p">[</span><span class="n">ref_channel</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="o">+</span><span class="n">channel</span><span class="p">]</span><span class="o">=</span> <span class="n">corr_data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">corr_data</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">Sigma_synth</span><span class="p">[</span><span class="n">ref_channel</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="o">+</span><span class="n">channel</span><span class="p">]</span><span class="o">=</span> <span class="n">corr_synth</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">corr_synth</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">ip</span> <span class="o">=</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">):</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sigma_data_synth</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Sigma_data</span><span class="o">*</span><span class="n">Sigma_synth</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">modal_contributions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">rho</span>
                
                <span class="k">if</span> <span class="n">plot_</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">modelist</span><span class="p">:</span>
                        <span class="n">axes</span><span class="p">[</span><span class="n">ip</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Mode </span><span class="si">{}</span><span class="s1">, </span><span class="se">\n</span><span class="s1"> MC=</span><span class="si">{:1.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">rho</span><span class="p">),</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
                        <span class="n">ip</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">plot_</span><span class="p">:</span>
            <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;tau [-]&#39;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;f [Hz]&#39;</span><span class="p">)</span>
<span class="c1">#             if plot_:</span>
<span class="c1">#                 fig.suptitle(str(np.sum(modal_contributions)))</span>
<span class="c1">#                 #plot.show()</span>
            <span class="c1">#print(str(np.sum(modal_contributions)))</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
                
        <span class="k">return</span> <span class="n">modal_frequencies</span><span class="p">,</span> <span class="n">modal_damping</span><span class="p">,</span> <span class="n">mode_shapes</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">modal_contributions</span></div>
        
<div class="viewcode-block" id="BRSSICovRef.synthesize_spectrum"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef.synthesize_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">synthesize_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        </span>
<span class="sd">        L = N*dt (duration = number_of_samples*sampling_period)</span>
<span class="sd">        P = N*df (maximal frequency = number of samples * frequency inverval)</span>
<span class="sd">        </span>
<span class="sd">        dt * df = 1/N</span>
<span class="sd">        L * P = N</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">f_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">tau_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">tau_max</span>
        <span class="n">delta_t</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span>
        
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">psd_mats_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">num_ref_channels</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">)</span>
        <span class="n">psd_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psd_mats_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        
        <span class="n">Lambda_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">get_corr_0</span><span class="p">()</span>
        
        
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tau_max</span><span class="p">):</span>
            
            <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">n</span><span class="o">*</span><span class="n">delta_t</span><span class="p">)</span>
            <span class="n">psd_matrix</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">I</span><span class="o">-</span><span class="n">A</span><span class="p">,</span><span class="n">G</span><span class="p">))</span> <span class="o">+</span><span class="n">Lambda_0</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">z</span><span class="o">*</span><span class="n">I</span><span class="o">-</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">psd_matrix</span> <span class="o">=</span> <span class="n">psd_matrix</span>        

        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">subplot</span><span class="p">()</span>
            <span class="n">omega_max</span> <span class="o">=</span> <span class="n">psd_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">omega_max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">)</span> 
            <span class="nb">print</span><span class="p">(</span><span class="n">freqs</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            
            <span class="k">for</span> <span class="n">ref_channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ref_channels</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_analised_channels</span><span class="p">):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psd_matrix</span><span class="p">[</span><span class="n">channel</span><span class="p">,</span><span class="n">ref_channel</span><span class="p">,:]))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">freqs</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
            <span class="n">plot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="BRSSICovRef.save_state"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef.save_state">[docs]</a>    <span class="k">def</span> <span class="nf">save_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        
        <span class="n">dirname</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
            
        <span class="c1">#             0         1           2           </span>
        <span class="c1">#self.state= [Toeplitz, State Mat., Modal Par.]</span>
        <span class="n">out_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;self.state&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">}</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="c1">#out_dict[&#39;self.prep_data&#39;]=self.prep_data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># covariances</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.toeplitz_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toeplitz_matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_columns&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># state models</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.U&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.S&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.V_T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1"># modal params</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.eigenvalues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_contributions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_contributions</span>
            
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">out_dict</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="BRSSICovRef.load_state"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.BRSSICovRef.load_state">[docs]</a>    <span class="nd">@classmethod</span> 
    <span class="k">def</span> <span class="nf">load_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Now loading previous results from  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        
        <span class="n">in_dict</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>    
        <span class="c1">#             0         1           2          </span>
        <span class="c1">#self.state= [Toeplitz, State Mat., Modal Par.]</span>
        <span class="k">if</span> <span class="s1">&#39;self.state&#39;</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
            <span class="n">state</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.state&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="k">for</span> <span class="n">this_state</span><span class="p">,</span> <span class="n">state_string</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Covariance Matrices Built&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;State Matrices Computed&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;Modal Parameters Computed&#39;</span><span class="p">,</span>
                                                    <span class="p">]):</span>
            <span class="k">if</span> <span class="n">this_state</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">state_string</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        <span class="n">setup_name</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">setup_name</span> <span class="o">==</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        
        <span class="k">assert</span> <span class="n">start_time</span> <span class="o">==</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">prep_data</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># covariances</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">toeplitz_matrix</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.toeplitz_matrix&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_columns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_columns&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># state models</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">U</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.U&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.S&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">V_T</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.V_T&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1"># modal params</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.eigenvalues&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_contributions</span> <span class="o">=</span> <span class="n">in_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;self.modal_contributions&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">ssi_object</span></div></div>

    
<div class="viewcode-block" id="PogerSSICovRef"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef">[docs]</a><span class="k">class</span> <span class="nc">PogerSSICovRef</span><span class="p">(</span><span class="n">ModalBase</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &quot;In the PoGER approach, first a nonparametric system model is identified </span>
<span class="sd">    for each setup separately. In the time domain, this nonparametric model </span>
<span class="sd">    consists of the correlations between all measured outputs.</span>
<span class="sd">    In a second step, the output correlations obtained from the different </span>
<span class="sd">    setups are stacked on top of each other. Extracting the modal parameters </span>
<span class="sd">    from the resulting correlation function yields global values for the </span>
<span class="sd">    eigenfrequencies and damping ratios. The identified partial mode shapes </span>
<span class="sd">    are stacked on top of each other in a global mode shape. However, due </span>
<span class="sd">    to the non-stationary ambient excitation level and the non-stationary </span>
<span class="sd">    ambient excitation color, it is necessary to re-scale the partial mode </span>
<span class="sd">    shapes in a least-squares sense, for instance to the reference DOFs of the</span>
<span class="sd">    first partial mode shape, just as in the PoSER approach&quot;</span>
<span class="sd">    </span>
<span class="sd">    from:</span>
<span class="sd">    Döhler, M.; Reynders, E.; Magalhaes, F.; Mevel, L.; Roeck, G. D. &amp; Cunha, A.</span>
<span class="sd">    Pre-and post-identification merging for multi-setup OMA with covariance-driven SSI </span>
<span class="sd">    28th International Modal Analysis Conference, 2010 , 57-70</span>
<span class="sd">    </span>
<span class="sd">    Analysis steps:</span>
<span class="sd">    * Create your geometry definitions</span>
<span class="sd">    * Create configuration files and channel-dof-assignments for each setup</span>
<span class="sd">    * Pre-process each setup using PreProcessData</span>
<span class="sd">    * Pre-compute correlations functions using PreProcessData.compute_correlation_functions </span>
<span class="sd">    (note: tau_max &gt;= num_block_columns + num_block_rows &gt;= 2 * num_block_columns + 1)</span>
<span class="sd">    * add the PreProcessData objects of each setup using add_setup</span>
<span class="sd">    * call pair_channels(), build_merged_subspace_matrix(), </span>
<span class="sd">    compute_state_matrices(), compute_modal_params()</span>
<span class="sd">    </span>
<span class="sd">    Notes on the reference channels:</span>
<span class="sd">    There are two different uses of reference channels:</span>
<span class="sd">    1. Reference channels for reducing the computational effort / </span>
<span class="sd">    improving results if noisy channels are present</span>
<span class="sd">    2. Reference channels for mode shape rescaling when multiple </span>
<span class="sd">    setups should be merged</span>
<span class="sd">    </span>
<span class="sd">    In PoGER merging the first group of reference channels are required </span>
<span class="sd">    for  joint identification. In this case, reference-based correlation</span>
<span class="sd">    functions are &quot;stacked on top of each other&quot; and then assembled into</span>
<span class="sd">    a joint Hankel matrix. Here, only the reference channels, that are </span>
<span class="sd">    present in all setups can be used. </span>
<span class="sd">    </span>
<span class="sd">    Based on each setups&#39; channel-dof-assignments and selected reference </span>
<span class="sd">    channels, the PogerSSICovRef class automatically determines the </span>
<span class="sd">    reference channels for:</span>
<span class="sd">    * joint identification and</span>
<span class="sd">    * mode shape rescaling / merging. </span>
<span class="sd">    Thus, by changing the reference channel definition in each setup, </span>
<span class="sd">    the used reference channels in joint identification can be influenced. </span>
<span class="sd">    The reference channels for modeshape rescaling are automatically</span>
<span class="sd">    generated, regardless of the the definition in the setup. Rescaling</span>
<span class="sd">    is always done with respect to the first setup, so a &quot;good&quot; setup should</span>
<span class="sd">    always be added first.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>    
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initializes class and all class variables </span>
<span class="sd">        channel definition: channels start at 0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1">#             0             1                2              3           4    </span>
        <span class="c1">#self.state= [Setups Added, Channels Paired, Subspace Mat., State Mat., Modal Par.]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span>  <span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span>        <span class="kc">False</span><span class="p">,</span>          <span class="kc">False</span><span class="p">,</span>          <span class="kc">False</span><span class="p">,</span>      <span class="kc">False</span><span class="p">]</span>
        
        <span class="c1"># __init__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">=</span> <span class="s1">&#39;merged_&#39;</span>
        <span class="c1">#self.start_times = []</span>
        
        <span class="c1"># add_setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ref_channels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1">#pair_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssi_ref_channels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_chan_dofs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_accel_channels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_velo_channels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_disp_channels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_num_channels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_analised_channels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#self.start_time = None</span>
        
        <span class="c1">#build_merged_subspace_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="kc">None</span>       

        <span class="c1"># compute_state_matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#self.V_T = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># compute_modal_params</span>
<span class="c1">#         self.eigenvalues = None</span>
<span class="c1">#         self.modal_damping = None</span>
<span class="c1">#         self.modal_frequencies = None</span>
<span class="c1">#         self.mode_shapes = None</span>
        

<div class="viewcode-block" id="PogerSSICovRef.add_setup"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef.add_setup">[docs]</a>    <span class="k">def</span> <span class="nf">add_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        todo: </span>
<span class="sd">        check that ref_channels are equal in each setup (by number and by DOF)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
      
        <span class="c1"># assure chan_dofs were assigned</span>
        <span class="k">assert</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">chan_dofs</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ref_channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ref_channels</span> <span class="o">!=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This setup contains a different number of reference channels (</span><span class="si">{}</span><span class="s1">), than the previous setups (</span><span class="si">{}</span><span class="s1">)!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ref_channels</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_ref_channels</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ref_channels</span><span class="p">,</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_ref_channels</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span><span class="p">,</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">tau_max</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">tau_max</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">+=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span>
        <span class="c1">#self.start_times.append(prep_data.start_time)</span>
        
        <span class="c1"># extract needed information and store them in a dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setups</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;setup_name&#39;</span><span class="p">:</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span><span class="p">,</span>
                           <span class="s1">&#39;num_analised_channels&#39;</span><span class="p">:</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span><span class="p">,</span>
                           <span class="s1">&#39;chan_dofs&#39;</span><span class="p">:</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">chan_dofs</span><span class="p">,</span>
                           <span class="s1">&#39;ref_channels&#39;</span><span class="p">:</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">ref_channels</span><span class="p">,</span>
                           <span class="c1">#&#39;roving_channels&#39;: prep_data.roving_channels,</span>
                           <span class="s1">&#39;accel_channels&#39;</span><span class="p">:</span><span class="n">prep_data</span><span class="o">.</span><span class="n">accel_channels</span><span class="p">,</span>
                           <span class="s1">&#39;velo_channels&#39;</span><span class="p">:</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">velo_channels</span><span class="p">,</span>
                           <span class="s1">&#39;disp_channels&#39;</span><span class="p">:</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">disp_channels</span><span class="p">,</span>
                           <span class="s1">&#39;corr_matrix&#39;</span><span class="p">:</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">corr_matrix</span><span class="p">,</span>
                           <span class="s1">&#39;start_time&#39;</span><span class="p">:</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span>
                           <span class="p">})</span>
                           
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Added setup &quot;</span><span class="si">{}</span><span class="s1">&quot; with </span><span class="si">{}</span><span class="s1"> channels&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span><span class="p">,</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="PogerSSICovRef.pair_channels"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef.pair_channels">[docs]</a>    <span class="k">def</span> <span class="nf">pair_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        pairs channels from all given setups for the poger merging methods</span>
<span class="sd">        </span>
<span class="sd">        ssi_reference channels are common to all setups</span>
<span class="sd">        rescale reference channels are common to at least two setups        </span>
<span class="sd">        </span>
<span class="sd">        finds common dofs from all setups and their respective channels</span>
<span class="sd">        generates new channel_dof_assignments with ascending channel numbers</span>
<span class="sd">        rescale reference channels are assumed to be equal to ssi_reference channels</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pairing channels and dofs...&#39;</span><span class="p">)</span>
        <span class="n">setups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setups</span>
        <span class="n">merged_chan_dofs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">merged_accel_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">merged_velo_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">merged_disp_channels</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># extract dofs from each setup and exclude channel numbers</span>
        <span class="c1"># merged_chan_dofs will be a list of chan_dof lists</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        merged_chan_dofs = [[dof of setup 0 channel 0,</span>
<span class="sd">                             dof of setup 0 channel 1,</span>
<span class="sd">                             ...</span>
<span class="sd">                             dof of setup 0 channel num_analised_channels]</span>
<span class="sd">                            [dof of setup 1 channel 0,</span>
<span class="sd">                             dof of setup 1 channel 1,</span>
<span class="sd">                             ...</span>
<span class="sd">                             dof of setup 1 channel num_analised_channels]</span>
<span class="sd">                            ...</span>
<span class="sd">                            [dof of setup num_setups channel 0,</span>
<span class="sd">                             dof of setup num_setups channel 1,</span>
<span class="sd">                             ...</span>
<span class="sd">                             dof of setup num_setups channel num_analised_channels]</span>
<span class="sd">                            ]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">for</span> <span class="n">setup</span> <span class="ow">in</span> <span class="n">setups</span><span class="p">:</span>    
            <span class="n">chan_dofs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">accel_channels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">velo_channels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">disp_channels</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="n">this_chan_dofs</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;chan_dofs&#39;</span><span class="p">]</span>
            <span class="n">this_num_analised_channels</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span>
            <span class="c1">#this_ref_channels = setup[&#39;ref_channels&#39;]</span>
            <span class="c1">#this_rov_channels = setup[&#39;roving_channels&#39;]</span>
            
            <span class="n">this_accel_channels</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;accel_channels&#39;</span><span class="p">]</span>
            <span class="n">this_velo_channels</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;velo_channels&#39;</span><span class="p">]</span>
            <span class="n">this_disp_channels</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;disp_channels&#39;</span><span class="p">]</span>
            
            <span class="n">this_chan_dofs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="c1"># chan dofs are now sorted by channel number</span>
            
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">this_num_analised_channels</span><span class="p">):</span>
                
                <span class="k">for</span> <span class="n">chan_dof</span> <span class="ow">in</span> <span class="n">this_chan_dofs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="n">chan_dof</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">node</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">elev</span> <span class="o">=</span> <span class="n">chan_dof</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chan_dof</span><span class="p">)</span><span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="n">chan_dof</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                        <span class="n">chan_dofs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">node</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">elev</span><span class="p">,</span> <span class="n">name</span><span class="p">])</span>
                        <span class="k">break</span>
                <span class="c1"># if channel has not been assigned to a DOF</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">chan_dofs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>
                    
                <span class="n">accel_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span> <span class="ow">in</span> <span class="n">this_accel_channels</span><span class="p">)</span>
                <span class="n">velo_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span> <span class="ow">in</span> <span class="n">this_velo_channels</span><span class="p">)</span>
                <span class="n">disp_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span> <span class="ow">in</span> <span class="n">this_disp_channels</span><span class="p">)</span>
                
            <span class="n">merged_chan_dofs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chan_dofs</span><span class="p">)</span>
            
            <span class="n">merged_accel_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accel_channels</span><span class="p">)</span>
            <span class="n">merged_velo_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">velo_channels</span><span class="p">)</span>
            <span class="n">merged_disp_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">disp_channels</span><span class="p">)</span>
            
        <span class="c1"># find dofs common to all setups</span>
        <span class="c1"># takes the dofs of the first setup as ssi_ref_dofs</span>
        <span class="c1"># loops over all setups and only keeps channels that are present in </span>
        <span class="c1"># the previous ssi_ref_dofs and the current setup</span>
        
        <span class="c1"># only ssi_ref_dofs can be used in the assembly of the hankel matrix</span>
        <span class="c1"># for mode shape rescaling the ref_dofs between the respective combination of two setups could be used</span>
        <span class="c1"># but the logic for this is not included here, therefore</span>
        <span class="c1"># only ssi_ref_dofs will be used for mode shape rescaling</span>
        
        <span class="n">ssi_ref_dofs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">merged_chan_dofs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>     
        <span class="k">for</span> <span class="n">chan_dofs</span> <span class="ow">in</span> <span class="n">merged_chan_dofs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">new_ref_dofs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">az</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="n">chan_dofs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">rnode</span><span class="p">,</span> <span class="n">raz</span><span class="p">,</span><span class="n">relev</span><span class="p">,</span><span class="n">rname</span> <span class="ow">in</span> <span class="n">ssi_ref_dofs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">rnode</span> <span class="ow">and</span> <span class="n">az</span> <span class="o">==</span> <span class="n">raz</span> <span class="ow">and</span> <span class="n">elev</span> <span class="o">==</span> <span class="n">relev</span> <span class="ow">and</span> <span class="n">name</span><span class="o">==</span><span class="n">rname</span><span class="p">:</span>
                        <span class="n">new_ref_dofs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">rnode</span><span class="p">,</span><span class="n">raz</span><span class="p">,</span><span class="n">relev</span><span class="p">,</span><span class="n">rname</span><span class="p">))</span>
                        <span class="k">break</span>
            <span class="n">ssi_ref_dofs</span> <span class="o">=</span> <span class="n">new_ref_dofs</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssi_ref_dofs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Could not find any DOF that is common to all setups.&#39;</span><span class="p">)</span>
            
        
        <span class="c1"># find channels for each common dof </span>
        <span class="c1">#     add the channel number to rescale_ref_channels; these will </span>
        <span class="c1">#        be used to get the reference modal coordinates in mode shape rescaling</span>
        <span class="c1">#     add the index of the channel in setups&#39; ref_channels to</span>
        <span class="c1">#        ssi_ref_channels; these will be used to assemble the Hankel</span>
        <span class="c1">#        matrix were each column is assembled from a single reference DOF (!)</span>
        <span class="c1">#        if reference channel orders have changed between setups, reordering</span>
        <span class="c1">#        is needed to achieve constistent columns of the Hankel matrix</span>

        
        <span class="n">ssi_ref_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#base_ssi_ref_channels = ssi_ref_channels[0]</span>
        <span class="n">rescale_ref_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">setup</span><span class="p">,</span> <span class="n">chan_dofs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">setups</span><span class="p">,</span> <span class="n">merged_chan_dofs</span><span class="p">):</span>
            <span class="c1">#prep_data = setup[&#39;prep_data&#39;]</span>
            <span class="n">this_ssi_ref_channels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">this_rescale_ref_channels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rnode</span><span class="p">,</span><span class="n">raz</span><span class="p">,</span><span class="n">relev</span><span class="p">,</span><span class="n">rname</span> <span class="ow">in</span> <span class="n">ssi_ref_dofs</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">channel</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">az</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;chan_dofs&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">rnode</span> <span class="ow">and</span> <span class="n">az</span> <span class="o">==</span> <span class="n">raz</span> <span class="ow">and</span> <span class="n">elev</span> <span class="o">==</span> <span class="n">relev</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="n">rname</span><span class="p">:</span>
                        <span class="c1">#index = i</span>
                        <span class="c1">#channel = setup[&#39;chan_dofs&#39;][index][0]</span>
                        
                        <span class="n">this_rescale_ref_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
                        
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;ref_channels&#39;</span><span class="p">]:</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Channel </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">) is common to multiple setups but not chosen as a reference channel.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="n">name</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">this_ref_index</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;ref_channels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                            <span class="n">this_ssi_ref_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_ref_index</span><span class="p">)</span>
                        
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Oops! Something went wrong. This should not happen!&#39;</span><span class="p">)</span>
            <span class="n">rescale_ref_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_rescale_ref_channels</span><span class="p">)</span>
            <span class="n">ssi_ref_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_ssi_ref_channels</span><span class="p">)</span>
            <span class="c1">#print(this_ssi_ref_channels)</span>
        
        <span class="c1"># reorder chan_dofs, accel_channels, etc. of the first setup</span>
        <span class="c1"># s.t. references come first, followed by rovings</span>
        <span class="c1"># refs are ordered by ssi_ref_dofs order</span>
        <span class="c1"># rovs are ordered by ascending channel number of the underlying setup</span>
        
        <span class="n">new_chan_dofs</span><span class="p">,</span> <span class="n">new_accel_channels</span><span class="p">,</span> <span class="n">new_velo_channels</span><span class="p">,</span> <span class="n">new_disp_channels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">chan_dofs</span><span class="p">,</span><span class="n">accel_channels</span><span class="p">,</span> <span class="n">velo_channels</span><span class="p">,</span> <span class="n">disp_channels</span> <span class="o">=</span> <span class="n">merged_chan_dofs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">merged_accel_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">merged_velo_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">merged_disp_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(chan_dofs,accel_channels, velo_channels, disp_channels )</span>
        <span class="k">for</span> <span class="n">rnode</span><span class="p">,</span><span class="n">raz</span><span class="p">,</span><span class="n">relev</span><span class="p">,</span><span class="n">rname</span> <span class="ow">in</span> <span class="n">ssi_ref_dofs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">node</span><span class="p">,</span><span class="n">az</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chan_dofs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">rnode</span> <span class="ow">and</span> <span class="n">az</span> <span class="o">==</span> <span class="n">raz</span> <span class="ow">and</span> <span class="n">elev</span> <span class="o">==</span> <span class="n">relev</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="n">rname</span><span class="p">:</span>
                    <span class="n">new_chan_dofs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chan_dofs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">new_accel_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accel_channels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">new_velo_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">velo_channels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">new_disp_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">disp_channels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;This should not happen, as all ref_dofs were previously checked to be present in each setup.&#39;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">chan_dofs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">accel_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">velo_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>                
            <span class="k">del</span> <span class="n">disp_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">new_chan_dofs</span> <span class="o">+=</span> <span class="n">chan_dofs</span>
        <span class="n">new_accel_channels</span> <span class="o">+=</span> <span class="n">accel_channels</span>
        <span class="n">new_velo_channels</span> <span class="o">+=</span> <span class="n">velo_channels</span>
        <span class="n">new_disp_channels</span> <span class="o">+=</span> <span class="n">disp_channels</span>
        
        <span class="n">merged_chan_dofs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">merged_accel_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">merged_velo_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">merged_disp_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_chan_dofs</span><span class="p">,</span> <span class="n">new_accel_channels</span><span class="p">,</span> <span class="n">new_velo_channels</span><span class="p">,</span> <span class="n">new_disp_channels</span>           
        
        <span class="c1"># delete channels of the reference dofs </span>
        <span class="k">for</span> <span class="n">chan_dofs</span><span class="p">,</span><span class="n">accel_channels</span><span class="p">,</span> <span class="n">velo_channels</span><span class="p">,</span> <span class="n">disp_channels</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">merged_chan_dofs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">merged_accel_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">merged_velo_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">merged_disp_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="c1">#prep_data = setup[&#39;prep_data&#39;]</span>
            <span class="k">for</span> <span class="n">rnode</span><span class="p">,</span><span class="n">raz</span><span class="p">,</span><span class="n">relev</span><span class="p">,</span><span class="n">rname</span> <span class="ow">in</span> <span class="n">ssi_ref_dofs</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">node</span><span class="p">,</span><span class="n">az</span><span class="p">,</span><span class="n">elev</span><span class="p">,</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chan_dofs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">rnode</span> <span class="ow">and</span> <span class="n">az</span> <span class="o">==</span> <span class="n">raz</span> <span class="ow">and</span> <span class="n">elev</span> <span class="o">==</span> <span class="n">relev</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="n">rname</span><span class="p">:</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;This should not happen, as all ref_dofs were previously checked to be present in each setup.&#39;</span><span class="p">)</span>
                <span class="c1"># remove the channel_dof_assignment of the reference channels for all setups </span>
                <span class="k">del</span> <span class="n">chan_dofs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">accel_channels</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">velo_channels</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>                
                <span class="k">del</span> <span class="n">disp_channels</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                    
        <span class="c1">#flatten chan_dofs and add ascending channel numbers</span>
        <span class="n">flattened</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">merged_chan_dofs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">:</span>
                <span class="n">val</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">channel</span><span class="p">)</span>
                <span class="n">flattened</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">channel</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">merged_chan_dofs</span> <span class="o">=</span> <span class="n">flattened</span>
        
        <span class="n">flattened</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">merged_accel_channels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                    <span class="n">flattened</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="n">channel</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">merged_accel_channels</span> <span class="o">=</span> <span class="n">flattened</span>
        
        <span class="n">flattened</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">merged_velo_channels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                    <span class="n">flattened</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="n">channel</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">merged_velo_channels</span> <span class="o">=</span> <span class="n">flattened</span>
        
        <span class="n">flattened</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">merged_disp_channels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                    <span class="n">flattened</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="n">channel</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">merged_disp_channels</span> <span class="o">=</span> <span class="n">flattened</span>
        
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">setup</span><span class="p">[</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">setup</span> <span class="ow">in</span> <span class="n">setups</span><span class="p">])</span>        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_accel_channels</span> <span class="o">=</span> <span class="n">merged_accel_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_velo_channels</span> <span class="o">=</span> <span class="n">merged_velo_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_disp_channels</span> <span class="o">=</span> <span class="n">merged_disp_channels</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">ssi_ref_channels</span> <span class="o">=</span> <span class="n">ssi_ref_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rescale_ref_channels</span> <span class="o">=</span> <span class="n">rescale_ref_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_chan_dofs</span> <span class="o">=</span> <span class="n">merged_chan_dofs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_num_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_chan_dofs</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_analised_channels</span> <span class="o">=</span> <span class="n">num_analised_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">stp</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stp</span> <span class="ow">in</span> <span class="n">setups</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">return</span> <span class="n">ssi_ref_channels</span><span class="p">,</span> <span class="n">merged_chan_dofs</span></div>
    
        
<div class="viewcode-block" id="PogerSSICovRef.build_merged_subspace_matrix"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef.build_merged_subspace_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">build_merged_subspace_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Builds a Block-HankelMatrix of Covariances with varying time lags</span>
<span class="sd">        </span>
<span class="sd">        ::</span>
<span class="sd">        </span>
<span class="sd">              &lt;- num_block_columns*num_ref_channels-&gt; _</span>
<span class="sd">            [     R_1      R_2      ...      R_i     ]^</span>
<span class="sd">            [     R_2      R_3      ...      R_2     ]num_block_rows*(num_num_ref_channels*num_setups)</span>
<span class="sd">            [     ...      ...      ...      ...     ]v</span>
<span class="sd">            [     R_i      ...      ...      R_2i-1  ]_</span>
<span class="sd">            </span>
<span class="sd">            R_1 =   [ R_1^1          ]</span>
<span class="sd">                    [ R_1^2          ]</span>
<span class="sd">                    [ ...            ]</span>
<span class="sd">                    [ R_1^num_setups ]</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">num_block_rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_block_rows</span> <span class="o">=</span> <span class="n">num_block_columns</span><span class="c1">#-10</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">num_block_columns</span><span class="o">+</span><span class="n">num_block_columns</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Correlation functions were pre-computed &#39;</span>
                <span class="s1">&#39;up to </span><span class="si">{}</span><span class="s1"> time lags, which is sufficient for assembling &#39;</span>
                <span class="s1">&#39;a Hankel-Matrix with up to </span><span class="si">{}</span><span class="s1"> x </span><span class="si">{}</span><span class="s1"> blocks. You requested &#39;</span>
                <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> x </span><span class="si">{}</span><span class="s1"> blocks&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="p">))</span>

        
        <span class="n">setups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setups</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assembling subspace matrix using pre-computed correlation&#39;</span>
              <span class="s1">&#39; functions from </span><span class="si">{}</span><span class="s1"> setups with </span><span class="si">{}</span><span class="s1"> block-columns and </span><span class="si">{}</span><span class="s1"> &#39;</span>
              <span class="s1">&#39;block rows&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">setups</span><span class="p">),</span> <span class="n">num_block_columns</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">ssi_ref_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssi_ref_channels</span>
        
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssi_ref_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tau_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span>
        
        <span class="n">subspace_matrix</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">))</span>
        <span class="n">end_row</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">block_row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sum_analised_channels</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">this_ssi_ref_channels</span><span class="p">,</span> <span class="n">setup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ssi_ref_channels</span><span class="p">,</span> <span class="n">setups</span><span class="p">):</span>
                
                <span class="n">this_analised_channels</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span>
                <span class="n">this_corr_matrix</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;corr_matrix&#39;</span><span class="p">]</span>
                
                
                <span class="n">this_corr_matrix</span> <span class="o">=</span> <span class="n">this_corr_matrix</span><span class="p">[:,</span><span class="n">this_ssi_ref_channels</span><span class="p">,:]</span>
                <span class="c1"># for each setup the order of the reference channels must be equal with respect to their DOFs</span>
                <span class="c1">#     we need a list of (local) ref_channels that corresponds to the ref_channels&#39; DOFs of the first setup</span>
                <span class="c1">#     ssi_ref_channels = [[ref_DOF_1 -&gt; index of ref_channel setup A, ref_DFO_2 -&gt; index of ref_channel setup A, ...], </span>
                <span class="c1">#                         [ref_DOF_1 -&gt; index of ref_channel setup B, ref_DFO_2 -&gt; index of ref_channel setup B, ...], </span>
                <span class="c1">#                         ...]</span>
                <span class="c1"># this_corr_matrix = this_corr_matrix[:,this_ssi_ref_channels] # just reorders the columns corresponding to the ref_channels of current setup</span>
                
                <span class="n">this_corr_matrix</span> <span class="o">=</span> <span class="n">this_corr_matrix</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">this_analised_channels</span><span class="p">,</span> <span class="n">num_ref_channels</span><span class="o">*</span><span class="n">tau_max</span><span class="p">),</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="n">this_block_column</span> <span class="o">=</span> <span class="n">this_corr_matrix</span><span class="p">[:,</span><span class="n">block_row</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">num_block_columns</span><span class="o">+</span><span class="n">block_row</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">]</span>
                
                
                
                <span class="n">begin_row</span> <span class="o">=</span> <span class="n">block_row</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="o">+</span><span class="n">sum_analised_channels</span>
                <span class="k">if</span> <span class="n">end_row</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">begin_row</span><span class="o">&gt;=</span><span class="n">end_row</span>
                <span class="n">end_row</span> <span class="o">=</span> <span class="n">begin_row</span> <span class="o">+</span> <span class="n">this_analised_channels</span>
                
                <span class="n">subspace_matrix</span><span class="p">[</span><span class="n">begin_row</span><span class="p">:</span><span class="n">end_row</span><span class="p">,:]</span><span class="o">=</span><span class="n">this_block_column</span>
                
                <span class="n">sum_analised_channels</span> <span class="o">+=</span> <span class="n">this_analised_channels</span>

            <span class="c1"># block_row    0                                            1</span>
            <span class="c1"># setup 0: zeile 0*this_analised_channels ... 1*this_analised_channels,   3*this_analised_channels ... 4*this_analised_channels</span>
            <span class="c1"># setup 1: zeile 1*this_analised_channels ... 2*this_analised_channels,   4*this_analised_channels ... 5*this_analised_channels</span>
            <span class="c1"># setup 2: zeile 2*this_analised_channels ... 3*this_analised_channels,   5*this_analised_channels ... 6*this_analised_channels  </span>
            <span class="c1"># (bc*num_setups+setup)*num_ref_channels</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">subspace_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span> <span class="o">=</span> <span class="n">subspace_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="n">num_block_rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span> <span class="o">=</span> <span class="n">num_block_columns</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="PogerSSICovRef.compute_state_matrices"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef.compute_state_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">compute_state_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_model_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>    
        
        <span class="n">subspace_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span>        
        
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_model_order</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">subspace_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>       
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_model_order</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span><span class="o">*</span><span class="n">subspace_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing state matrices with pinv-based method, with maximum model order </span><span class="si">{}</span><span class="s1">...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">))</span>
        
        <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">subspace_matrix</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># choose highest possible model order</span>


        <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,:</span><span class="n">max_model_order</span><span class="p">]</span>
        <span class="c1">#V_T = V_T[:max_model_order,:]     </span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">U</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">S</span>
        <span class="c1">#self.V_T = V_T</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span><span class="o">=</span><span class="n">max_model_order</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span></div>
        
<div class="viewcode-block" id="PogerSSICovRef.compute_modal_params"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef.compute_modal_params">[docs]</a>    <span class="k">def</span> <span class="nf">compute_modal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_model_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
        
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_model_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
            
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">merged_num_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_num_channels</span>
        <span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>
        
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="n">S_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="n">max_model_order</span><span class="p">],</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
        
        <span class="n">O</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">S_2</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing modal parameters...&#39;</span><span class="p">)</span>
    
        <span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">modal_damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">merged_num_channels</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="n">printsteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">):</span>                   
            <span class="k">while</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">printsteps</span><span class="p">:</span> 
                <span class="k">del</span> <span class="n">printsteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1">#print(&#39;\n\n{}\n\n&#39;.format(order))</span>
            
            <span class="n">On_up</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
            <span class="n">On_down</span> <span class="o">=</span> <span class="n">O</span><span class="p">[</span><span class="n">num_analised_channels</span><span class="p">:</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,:</span><span class="n">order</span><span class="p">]</span>
            
            <span class="n">state_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up</span><span class="p">),</span> <span class="n">On_down</span><span class="p">)</span>             
    
            <span class="n">C</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_analised_channels</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>      
            
            <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">state_matrix</span><span class="p">)</span>
                     
            <span class="n">conj_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_conjugates</span><span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">,</span><span class="n">inds_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">):</span>
                
                <span class="n">lambda_i</span> <span class="o">=</span><span class="n">eigval</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                
                <span class="n">ident</span> <span class="o">=</span> <span class="n">eigval</span> <span class="o">==</span> <span class="n">lambda_i</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="n">ident</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>                
                <span class="n">ident</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span>
                    
                <span class="n">a_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">)))</span>
                <span class="n">b_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">))</span>
                <span class="n">freq_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sampling_rate</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">damping_i</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">ind</span><span class="p">])</span>
                <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                
                <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_by_references</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">)</span>
                <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate_quantities</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_accel_channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_velo_channels</span><span class="p">,</span> <span class="n">freq_i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  
       
                <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">))</span>
                <span class="n">s_ik</span> <span class="o">=</span> <span class="n">mode_shape_i</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">alpha_ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span>
                <span class="n">e_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">e_k</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">mode_shape_i</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">alpha_ik</span><span class="p">)</span>
                
                <span class="n">modal_frequencies</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">freq_i</span>
                <span class="n">modal_damping</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">damping_i</span>
                <span class="n">mode_shapes</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">mode_shape_i</span>    
                <span class="n">eigenvalues</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">lambda_i</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">modal_frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="n">modal_damping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">mode_shapes</span>   
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">eigenvalues</span> 

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>
        
<div class="viewcode-block" id="PogerSSICovRef.rescale_by_references"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef.rescale_by_references">[docs]</a>    <span class="k">def</span> <span class="nf">rescale_by_references</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_shape</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is PoGer Rescaling</span>
<span class="sd">        </span>
<span class="sd">        walks over setups, </span>
<span class="sd">         * extracts setup&#39;s part from the modeshape, and </span>
<span class="sd">         * compute rescaling factor from this setup&#39;s reference channels with respect to the first setup</span>
<span class="sd">         * rescales this setup&#39;s roving channels and assembles final modeshape vector</span>
<span class="sd">        </span>
<span class="sd">        reference channel_pairs and final channel-dof-assignments have been determined by function pair_channels</span>
<span class="sd">        note: reference channels for SSI need not necessarily be reference channels for rescaling and vice versa</span>
<span class="sd">        </span>
<span class="sd">        TODO:</span>
<span class="sd">        * rescale all setups jointly using a least-squares approach</span>
<span class="sd">        </span>
<span class="sd">        :math:`S_\phi * \Alpha = [n*1, 0 .. 0]`</span>
<span class="sd">        </span>
<span class="sd">        :math:`\phi^{ref}_i` : Reference-sensor part of modeshape estimated from setup :math:`i = 0 .. n`</span>
<span class="sd">        :matH:`j_{max} = argmax(\Pi_i |\phi^{ref}_i|)` : maximal modal component in all setups → will be approximately scaled to 1, must belong to the same sensor in each setup</span>
<span class="sd">        </span>
<span class="sd">        ..math::</span>
<span class="sd">        </span>
<span class="sd">            S_\phi =  \begin{bmatrix}</span>
<span class="sd">            \phi^{ref}_{0,j_{max}}&amp;  \phi^{ref}_{1,j_{max}}&amp; ..&amp;            ..&amp;               \phi^{ref}_{n,j_{max}} \\</span>
<span class="sd">            \phi^{ref}_0&amp;            -\phi^{ref}_1&amp;          0&amp;             ..&amp;               0                      \\</span>
<span class="sd">            \phi^{ref}_0&amp;            0&amp;                      -\phi^{ref}_2&amp; ..&amp;               0                      \\</span>
<span class="sd">            .                        &amp;.                       &amp;.             &amp; .             &amp; .                      \\</span>
<span class="sd">            .                        &amp;.                       &amp;.             &amp; .             &amp; .                      \\</span>
<span class="sd">            \phi^{ref}_0&amp;            0&amp;                      0&amp;             ..&amp;               -\phi^{ref}_n          \\</span>
<span class="sd">            0&amp;                       \phi^{ref}_1&amp;           -\phi^{ref}_2&amp; ..&amp;               0                      \\</span>
<span class="sd">            .                        &amp;.                      &amp; .             &amp; .             &amp; .                      \\</span>
<span class="sd">            .                        &amp;.                      &amp; .             &amp; .             &amp; .                      \\</span>
<span class="sd">            0&amp;                       \phi^{ref}_1&amp;           0&amp;             ..&amp;               -\phi^{ref}_n          \\</span>
<span class="sd">            .                        &amp;.                      &amp; .             &amp; .             &amp; .                      \\</span>
<span class="sd">            .                        &amp;.                      &amp; .             &amp; .             &amp; .                      \\</span>
<span class="sd">            0&amp;                       0&amp;                      \phi^{ref}_2&amp;  ..&amp;               -\phi^{ref}_n          \\</span>
<span class="sd">            .                        &amp;.                      &amp; .             &amp; .             &amp; .                      \\</span>
<span class="sd">            .                        &amp;.                      &amp; .             &amp; .            &amp;  .                      \\</span>
<span class="sd">            0&amp;                       0&amp;                      0&amp;             \phi^{ref}_{n-1}&amp; -\phi^{ref}_n            </span>
<span class="sd">            \end{bmatrix}</span>
<span class="sd">        </span>
<span class="sd">        if references are the same in all setups</span>
<span class="sd">        </span>
<span class="sd">        dimensions :math:`= 1 + (n_setups ! )* n_ref_channels x n_setups` </span>
<span class="sd">        </span>
<span class="sd">        not quite exact, since different setups may share different references</span>
<span class="sd">        </span>
<span class="sd">        → list based assembly of the :math:`S_\phi` matrix</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">new_mode_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">merged_num_channels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            
        <span class="n">start_row_scaled</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end_row_scaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span>
        
        <span class="n">row_unscaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span>
        
        <span class="n">new_mode_shape</span><span class="p">[</span><span class="n">start_row_scaled</span><span class="p">:</span><span class="n">end_row_scaled</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode_shape</span><span class="p">[</span><span class="n">start_row_scaled</span><span class="p">:</span><span class="n">end_row_scaled</span><span class="p">]</span>
        
<span class="c1">#         for setup_num,setup in enumerate(self.setups):</span>
<span class="c1">#             if setup_num == 0: continue</span>
<span class="c1">#             #ssi_ref_channels is ref_channels with respect to setup not to merged mode shape </span>
<span class="c1">#              </span>
<span class="c1">#             base_refs = self.rescale_ref_channels[0]</span>
<span class="c1">#              </span>
<span class="c1">#             this_refs = self.rescale_ref_channels[setup_num]</span>
<span class="c1">#             this_all = range(setup[&#39;num_analised_channels&#39;])#setup[&#39;roving_channels&#39;]+setup[&#39;ref_channels&#39;]</span>
<span class="c1">#             this_rovs = list(set(this_all).difference(this_refs))</span>
<span class="c1">#              </span>
<span class="c1">#             this_refs = [int(ref+row_unscaled) for ref in this_refs]</span>
<span class="c1">#             this_rovs = [rov+row_unscaled for rov in this_rovs]</span>
<span class="c1">#  </span>
<span class="c1">#             mode_refs_base = mode_shape[base_refs]</span>
<span class="c1">#             mode_refs_this = mode_shape[this_refs]</span>
<span class="c1">#             mode_refs_this_conj = mode_refs_this.conj()</span>
<span class="c1">#             mode_rovs_this = mode_shape[this_rovs]</span>
<span class="c1">#              </span>
<span class="c1">#             numer = np.inner(mode_refs_this_conj, mode_refs_base )</span>
<span class="c1">#             denom = np.inner(mode_refs_this_conj, mode_refs_this )</span>
<span class="c1">#             scale_fact=numer/denom    </span>
<span class="c1">#                  </span>
<span class="c1">#             start_row_scaled = end_row_scaled</span>
<span class="c1">#             end_row_scaled += len(this_rovs)</span>
<span class="c1">#             #print(mode_refs_base, mode_refs_this, scale_fact)</span>
<span class="c1">#             new_mode_shape[start_row_scaled:end_row_scaled] = scale_fact * mode_rovs_this</span>
<span class="c1">#              </span>
<span class="c1">#             row_unscaled += setup[&#39;num_analised_channels&#39;]</span>
<span class="c1">#         return new_mode_shape</span>

        <span class="n">num_setups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setups</span><span class="p">)</span>
        
        <span class="n">S_phi</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#assemble the first line</span>
        <span class="n">all_ref_modes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">setup_num</span><span class="p">,</span> <span class="n">setup</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setups</span><span class="p">):</span>
            <span class="n">this_refs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_ref_channels</span><span class="p">[</span><span class="n">setup_num</span><span class="p">]</span>
            <span class="n">mode_refs_this</span> <span class="o">=</span> <span class="n">mode_shape</span><span class="p">[</span><span class="n">this_refs</span><span class="p">]</span>
            <span class="n">all_ref_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode_refs_this</span><span class="p">)</span>
        <span class="n">all_ref_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_ref_modes</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">max_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">all_ref_modes</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">S_phi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_ref_modes</span><span class="p">[</span><span class="n">max_ind</span><span class="p">:</span><span class="n">max_ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,:])</span>
        
        <span class="c1">#assemble S_phi</span>
        <span class="n">row_unscaled_1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">setup_num_1</span><span class="p">,</span> <span class="n">setup_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setups</span><span class="p">):</span>
            <span class="n">row_unscaled_2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">setup_num_2</span><span class="p">,</span> <span class="n">setup_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setups</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">setup_num_2</span> <span class="o">&lt;=</span> <span class="n">setup_num_1</span><span class="p">:</span> 
                    
                    <span class="n">row_unscaled_2</span> <span class="o">+=</span> <span class="n">setup_2</span><span class="p">[</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span>    
                    <span class="k">continue</span>
                <span class="c1">#ssi_ref_channels is ref_channels with respect to setup not to merged mode shape </span>
                
                <span class="n">base_refs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_ref_channels</span><span class="p">[</span><span class="n">setup_num_1</span><span class="p">]</span>
                
                <span class="n">this_refs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_ref_channels</span><span class="p">[</span><span class="n">setup_num_2</span><span class="p">]</span>
                <span class="c1">#this_all = range(setup[&#39;num_analised_channels&#39;])#setup[&#39;roving_channels&#39;]+setup[&#39;ref_channels&#39;]</span>
                <span class="c1">#this_rovs = list(set(this_all).difference(this_refs))</span>
                
                <span class="n">base_refs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ref</span><span class="o">+</span><span class="n">row_unscaled_1</span><span class="p">)</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">base_refs</span><span class="p">]</span>
                <span class="n">this_refs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ref</span><span class="o">+</span><span class="n">row_unscaled_2</span><span class="p">)</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">this_refs</span><span class="p">]</span>
                <span class="c1">#this_rovs = [rov+row_unscaled for rov in this_rovs]</span>
    
                <span class="n">mode_refs_base</span> <span class="o">=</span> <span class="n">mode_shape</span><span class="p">[</span><span class="n">base_refs</span><span class="p">]</span>
                <span class="n">mode_refs_this</span> <span class="o">=</span> <span class="n">mode_shape</span><span class="p">[</span><span class="n">this_refs</span><span class="p">]</span>
                
                <span class="n">this_S_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">base_refs</span><span class="p">),</span><span class="n">num_setups</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">this_S_phi</span><span class="p">[:,</span><span class="n">setup_num_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode_refs_base</span>
                <span class="n">this_S_phi</span><span class="p">[:,</span><span class="n">setup_num_2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">mode_refs_this</span>
                
                <span class="n">S_phi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_S_phi</span><span class="p">)</span>
                <span class="n">row_unscaled_2</span> <span class="o">+=</span> <span class="n">setup_2</span><span class="p">[</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span>    
            <span class="n">row_unscaled_1</span> <span class="o">+=</span> <span class="n">setup_1</span><span class="p">[</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span>    

        <span class="n">S_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">S_phi</span><span class="p">)</span>
        
        <span class="c1"># compute scaling factors</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">S_phi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">num_setups</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>
        <span class="c1">#rhs[0]=1+0j</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">S_phi</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        
        
        <span class="n">end_row_scaled</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">#self.setups[0][&#39;num_analised_channels&#39;]</span>
        <span class="n">row_unscaled</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">#self.setups[0][&#39;num_analised_channels&#39;]</span>
        <span class="k">for</span> <span class="n">setup_num</span><span class="p">,</span><span class="n">setup</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setups</span><span class="p">):</span>
            
             
            <span class="n">this_refs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_ref_channels</span><span class="p">[</span><span class="n">setup_num</span><span class="p">]</span>
            <span class="n">this_all</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">setup</span><span class="p">[</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">])</span><span class="c1">#setup[&#39;roving_channels&#39;]+setup[&#39;ref_channels&#39;]</span>
            <span class="n">this_rovs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">this_all</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">this_refs</span><span class="p">))</span>
             

            <span class="n">this_rovs</span> <span class="o">=</span> <span class="p">[</span><span class="n">rov</span><span class="o">+</span><span class="n">row_unscaled</span> <span class="k">for</span> <span class="n">rov</span> <span class="ow">in</span> <span class="n">this_rovs</span><span class="p">]</span>

            <span class="n">mode_rovs_this</span> <span class="o">=</span> <span class="n">mode_shape</span><span class="p">[</span><span class="n">this_rovs</span><span class="p">]</span>
             
            <span class="n">scale_fact</span><span class="o">=</span><span class="n">alpha</span><span class="p">[</span><span class="n">setup_num</span><span class="p">]</span>    
            
            <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">base_refs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_ref_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                 
                
                 
                <span class="n">this_refs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ref</span><span class="o">+</span><span class="n">row_unscaled</span><span class="p">)</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">this_refs</span><span class="p">]</span>
                <span class="c1">#this_rovs = [rov+row_unscaled for rov in this_rovs]</span>
     
                <span class="n">mode_refs_base</span> <span class="o">=</span> <span class="n">mode_shape</span><span class="p">[</span><span class="n">base_refs</span><span class="p">]</span>
                <span class="n">mode_refs_this</span> <span class="o">=</span> <span class="n">mode_shape</span><span class="p">[</span><span class="n">this_refs</span><span class="p">]</span>
                <span class="n">mode_refs_this_conj</span> <span class="o">=</span> <span class="n">mode_refs_this</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                 
                <span class="n">numer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">mode_refs_this_conj</span><span class="p">,</span> <span class="n">mode_refs_base</span> <span class="p">)</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">mode_refs_this_conj</span><span class="p">,</span> <span class="n">mode_refs_this</span> <span class="p">)</span>
                <span class="n">scale_fact</span><span class="o">=</span><span class="n">numer</span><span class="o">/</span><span class="n">denom</span>    

                <span class="c1">#print( scale_fact, scale_fact_old)</span>
                 
            
            <span class="k">if</span> <span class="n">setup_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mode_refs_this</span> <span class="o">=</span> <span class="n">mode_shape</span><span class="p">[</span><span class="n">this_refs</span><span class="p">]</span>
                <span class="n">start_row_scaled</span> <span class="o">=</span> <span class="n">end_row_scaled</span>
                <span class="n">end_row_scaled</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_refs</span><span class="p">)</span>
                <span class="n">new_mode_shape</span><span class="p">[</span><span class="n">start_row_scaled</span><span class="p">:</span><span class="n">end_row_scaled</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_fact</span> <span class="o">*</span> <span class="n">mode_refs_this</span>
            
            
            <span class="n">start_row_scaled</span> <span class="o">=</span> <span class="n">end_row_scaled</span>
            <span class="n">end_row_scaled</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_rovs</span><span class="p">)</span>
            
            <span class="n">new_mode_shape</span><span class="p">[</span><span class="n">start_row_scaled</span><span class="p">:</span><span class="n">end_row_scaled</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale_fact</span> <span class="o">*</span> <span class="n">mode_rovs_this</span>
             
            <span class="n">row_unscaled</span> <span class="o">+=</span> <span class="n">setup</span><span class="p">[</span><span class="s1">&#39;num_analised_channels&#39;</span><span class="p">]</span>      
        <span class="k">return</span> <span class="n">new_mode_shape</span>     </div>
    
<div class="viewcode-block" id="PogerSSICovRef.save_state"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef.save_state">[docs]</a>    <span class="k">def</span> <span class="nf">save_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        
        <span class="n">dirname</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
            
        <span class="c1">#             0             1                2              3           4    </span>
        <span class="c1">#self.state= [Setups Added, Channels Paired, Subspace Mat., State Mat., Modal Par.]</span>
        <span class="n">out_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;self.state&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">}</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="c1">#out_dict[&#39;self.start_times&#39;]=self.start_times</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># add_setup</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.setups&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setups</span>               
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.sampling_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate</span>        
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_ref_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ref_channels</span>     
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.tau_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_max</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1">#pair_channels         </span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.ssi_ref_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssi_ref_channels</span>  
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.rescale_ref_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_ref_channels</span>     
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_chan_dofs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_chan_dofs</span>     
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_accel_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_accel_channels</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_velo_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_velo_channels</span> 
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_disp_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_disp_channels</span> 
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_num_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_num_channels</span>  
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_analised_channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_analised_channels</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.start_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span>              
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1">#build_merged_subspace_matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.subspace_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span>      
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_columns&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span>    
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>           
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span><span class="c1"># compute_state_matrices</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.U&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>                    
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.S&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>      
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span><span class="c1"># compute_modal_params </span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.eigenvalues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span>          
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span>        
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span>    
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span>          

        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">out_dict</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="PogerSSICovRef.load_state"><a class="viewcode-back" href="../classes/SSICovRef.html#SSICovRef.PogerSSICovRef.load_state">[docs]</a>    <span class="nd">@classmethod</span> 
    <span class="k">def</span> <span class="nf">load_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Now loading previous results from  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        
        <span class="n">in_dict</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    
        <span class="c1">#             0             1                2              3           4    </span>
        <span class="c1">#self.state= [Setups Added, Channels Paired, Subspace Mat., State Mat., Modal Par.]</span>
        <span class="k">if</span> <span class="s1">&#39;self.state&#39;</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
            <span class="n">state</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.state&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="k">for</span> <span class="n">this_state</span><span class="p">,</span> <span class="n">state_string</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Setups added&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;Channels paired, channel-DOF assignments generated&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;Subspace matrix built&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;State matrices computed&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;Modal parameters computed&#39;</span><span class="p">,</span>
                                                    <span class="p">]):</span>
            <span class="k">if</span> <span class="n">this_state</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">state_string</span><span class="p">)</span>
        
        <span class="c1">#assert isinstance(prep_data, PreprocessData)</span>
        <span class="n">setup_name</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">=</span> <span class="n">setup_name</span>
        
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="c1">#debug_here</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># add_setup</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">setups</span>                 <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.setups&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">sampling_rate</span>          <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.sampling_rate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_ref_channels</span>       <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_ref_channels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>     
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">tau_max</span>                <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.tau_max&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>         
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1">#pair_channels         </span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">ssi_ref_channels</span>       <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.ssi_ref_channels&#39;</span><span class="p">]]</span>  
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">rescale_ref_channels</span>   <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.rescale_ref_channels&#39;</span><span class="p">]]</span>     
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">merged_chan_dofs</span>       <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">cd</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">str</span><span class="p">(</span><span class="n">cd</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cd</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cd</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">cd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)]</span> 
                                                    <span class="k">for</span> <span class="n">cd</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_chan_dofs&#39;</span><span class="p">]]</span>  
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">merged_accel_channels</span>  <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_accel_channels&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">merged_velo_channels</span>   <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_velo_channels&#39;</span><span class="p">])</span> 
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">merged_disp_channels</span>   <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_disp_channels&#39;</span><span class="p">])</span> 
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">merged_num_channels</span>    <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.merged_num_channels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>  
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_analised_channels</span>  <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_analised_channels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> 
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">start_time</span>             <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.start_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1">#build_merged_subspace_matrix</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_matrix</span>        <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.subspace_matrix&#39;</span><span class="p">]</span>      
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_columns</span>      <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_columns&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>    
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_rows</span>         <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>                
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span><span class="c1"># compute_state_matrices</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">U</span>                      <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.U&#39;</span><span class="p">]</span>                    
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">S</span>                      <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.S&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">max_model_order</span>        <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>       
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span><span class="c1"># compute_modal_params </span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">eigenvalues</span>            <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.eigenvalues&#39;</span><span class="p">]</span>          
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_damping</span>          <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span>        
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_frequencies</span>      <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span>    
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">mode_shapes</span>            <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span> 

        
        <span class="k">return</span> <span class="n">ssi_object</span></div></div>



    
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Simon Marwitz, Volkmar Zabel, Andrei Udrea.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>