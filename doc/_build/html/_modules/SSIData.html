

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>SSIData &mdash; pyOMA  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pyOMA
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../classes/preprocessing.html">Pre-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes/oma.html">Operational Modal Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes/postprocessing.html">Post-processing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyOMA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>SSIData</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for SSIData</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Thu Oct 16 14:41:56 2014</span>

<span class="sd">@author: volkmar</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="c1">#import sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="c1">#import json</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="c1">#import ctypes as c</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="c1">#import datetime</span>
<span class="c1">#from copy import deepcopy</span>

<span class="kn">from</span> <span class="nn">PreprocessingTools</span> <span class="kn">import</span> <span class="n">PreprocessData</span>
<span class="c1">#import pyximport </span>
<span class="c1">#pyximport.install()</span>


<span class="c1">#import cython_code.cython_helpers</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">TODO:</span>
<span class="sd">- define unit tests to check functionality after changes</span>
<span class="sd">- update SSIData to follow the generalized subspace algorithm approach by doehler et.al.</span>
<span class="sd">- parallel state-estimation for SSI-DataMEC (different starting points and overlapping states)</span>
<span class="sd">- add switch to keep synthesized time-histories</span>
<span class="sd">- try to </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1">#from decomp_qr_VZ import qr</span>
<span class="c1">#####################################################################################################################################</span>
<div class="viewcode-block" id="rq_decomp"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.rq_decomp">[docs]</a><span class="k">def</span> <span class="nf">rq_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">q</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="ql_decomp"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.ql_decomp">[docs]</a><span class="k">def</span> <span class="nf">ql_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="lq_decomp"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.lq_decomp">[docs]</a><span class="k">def</span> <span class="nf">lq_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    a: array_like, shape (M,N)</span>
<span class="sd">    l: (M,K)</span>
<span class="sd">    q: (K,N)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="n">r</span><span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fact</span><span class="p">,(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
            <span class="n">q</span><span class="o">*=</span> <span class="n">fact</span>
            <span class="c1">#print(np.allclose(a.T,q.dot(r)))</span>
            
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">T</span></div>
    
<div class="viewcode-block" id="SSIData"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData">[docs]</a><span class="k">class</span> <span class="nc">SSIData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prep_data</span><span class="p">):</span>    
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        channel definition: channels start at 0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span> <span class="o">=</span><span class="n">prep_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        <span class="c1">#             0         1           2             3</span>
        <span class="c1">#self.state= [Hankel, QR_decomp.,  State matr.,  Modal Par.]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span>  <span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span>    <span class="kc">False</span><span class="p">,</span>     <span class="kc">False</span><span class="p">,</span>        <span class="kc">False</span><span class="p">]</span>
        
        <span class="c1">#self.num_block_columns = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix_T</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_i_ref</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="kc">None</span>
            
<div class="viewcode-block" id="SSIData.init_from_config"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.init_from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">init_from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">conf_file</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">conf_file</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">conf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Number of Block-Rows:&#39;</span>
            <span class="n">num_block_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Maximum Model Order:&#39;</span>
            <span class="n">max_model_order</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Use Multiprocessing:&#39;</span>
            <span class="n">multiprocessing</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;yes&#39;</span>
        
            
        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">prep_data</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">build_block_hankel</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="n">multiprocess</span><span class="o">=</span><span class="n">multiprocessing</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_projection_matrix</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="n">multiprocess</span><span class="o">=</span><span class="n">multiprocessing</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_state_matrices</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_modal_params</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">multiprocessing</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max_model_order = &#39;</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ssi_object.max_model_order = &#39;</span><span class="p">,</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">max_model_order</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">ssi_object</span></div>

        
<div class="viewcode-block" id="SSIData.build_block_hankel"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.build_block_hankel">[docs]</a>    <span class="k">def</span> <span class="nf">build_block_hankel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiprocess</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Builds a Block-Hankel Matrix of the measured time series with varying time lags</span>
<span class="sd">            | &lt;- num_time samples - num_block_rows-&gt;     |_</span>
<span class="sd">            |     y_0      y_1      ...      y_(j-1)     |^</span>
<span class="sd">            |     y_1      y_2      ...      y_j         |num_block_rows (=i)*num_analised_channels</span>
<span class="sd">            |     ...      ...      ...      ...         |v</span>
<span class="sd">            |     y_(2i-1)   y_(2i)  ...     y_(2i+j-2)  |_</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#print(multiprocess)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        
        <span class="c1">#self.num_block_columns=num_block_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span><span class="o">=</span><span class="n">num_block_rows</span>
        <span class="n">total_time_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">total_time_steps</span>
        <span class="n">ref_channels</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">ref_channels</span><span class="p">)</span>
        <span class="n">roving_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">roving_channels</span>
        <span class="n">measurement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span>
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span> 
        
        <span class="c1"># Reduce maximal size of Hankel matrix to a fixed value </span>
        <span class="n">flexlimit</span> <span class="o">=</span> <span class="n">total_time_steps</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">fixlimit</span> <span class="o">=</span> <span class="mi">10000</span>   <span class="c1">#14000</span>
        <span class="n">extract_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">flexlimit</span><span class="p">,</span> <span class="p">(</span><span class="n">fixlimit</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;extract_length = &#39;</span><span class="p">,</span> <span class="n">extract_length</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">fixlimit</span> <span class="o">&lt;</span> <span class="n">total_time_steps</span><span class="p">:</span>
            <span class="n">measurement</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">fixlimit</span><span class="o">+</span><span class="mi">1</span><span class="p">),:]</span>
            <span class="n">total_time_steps</span> <span class="o">=</span> <span class="n">fixlimit</span>
                       
        <span class="c1"># Extract reference time series </span>
        <span class="n">all_channels</span> <span class="o">=</span> <span class="n">ref_channels</span> <span class="o">+</span> <span class="n">roving_channels</span>
        <span class="n">all_channels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                              
        <span class="k">if</span> <span class="p">(</span><span class="n">num_ref_channels</span> <span class="o">&lt;</span> <span class="n">num_analised_channels</span><span class="p">):</span>
            
            <span class="n">refs</span> <span class="o">=</span> <span class="p">(</span><span class="n">measurement</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">extract_length</span><span class="p">,</span><span class="n">ref_channels</span><span class="p">])</span>
                     
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refs</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">extract_length</span><span class="p">,:]</span>

       
           
        <span class="c1">###############################################################################</span>
        <span class="c1">######## Create transpose of the block Hankel matrix [Y_(0|2i-1)]^T ###########</span>
        <span class="c1">###############################################################################</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating block Hankel matrix...&#39;</span><span class="p">)</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="n">num_block_rows</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">total_time_steps</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span>
        <span class="n">doehler_style</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">doehler_style</span><span class="p">:</span>
            <span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">i</span>
            
            <span class="n">Y_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
            <span class="n">Y_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">p</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
            
            
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">Y_minus</span><span class="p">[(</span><span class="n">q</span><span class="o">-</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">q</span><span class="o">-</span><span class="n">ii</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">refs</span><span class="p">[</span><span class="n">ii</span><span class="p">:(</span><span class="n">ii</span><span class="o">+</span><span class="n">j</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
                <span class="n">Y_plus</span><span class="p">[</span><span class="n">ii</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">:(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">ii</span><span class="p">):(</span><span class="n">i</span><span class="o">+</span><span class="n">ii</span><span class="o">+</span><span class="n">j</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
                
            <span class="n">Hankel_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Y_minus</span><span class="p">,</span><span class="n">Y_plus</span><span class="p">))</span>
            <span class="n">Hankel_matrix</span> <span class="o">/=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix</span> <span class="o">=</span> <span class="n">Hankel_matrix</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Hankel_matrix_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">j</span><span class="p">,(</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">num_analised_channels</span><span class="o">*</span><span class="n">i</span><span class="p">)))</span>
            
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                
                <span class="n">Hankel_matrix_T</span><span class="p">[:,</span> <span class="n">ii</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">refs</span><span class="p">[</span><span class="n">ii</span><span class="p">:(</span><span class="n">ii</span><span class="o">+</span><span class="n">j</span><span class="p">)]</span>
            
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                
                <span class="n">Hankel_matrix_T</span><span class="p">[:,</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">num_ref_channels</span> <span class="o">+</span> <span class="n">ii</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">):</span> \
                    <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">num_ref_channels</span> <span class="o">+</span> <span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">)]</span> <span class="o">=</span> \
                    <span class="n">measurement</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">ii</span><span class="p">):(</span><span class="n">i</span><span class="o">+</span><span class="n">ii</span><span class="o">+</span><span class="n">j</span><span class="p">)]</span>
            
            <span class="n">Hankel_matrix_T</span> <span class="o">=</span> <span class="n">Hankel_matrix_T</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    
            <span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix_T</span> <span class="o">=</span> <span class="n">Hankel_matrix_T</span>              
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span></div>
          
          
          
          
<div class="viewcode-block" id="SSIData.compute_projection_matrix"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.compute_projection_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">compute_projection_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiprocess</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            
        <span class="c1">###############################################################################</span>
        <span class="c1">####################### QR decomposition of [Y_(0|2i-1)]^T ####################</span>
        <span class="c1">###############################################################################</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing QR decomposition of block Hankel matrix...&#39;</span><span class="p">)</span>
        
        <span class="n">Hankel_matrix_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix_T</span>              
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span> 
        <span class="n">i</span> <span class="o">=</span> <span class="n">num_block_rows</span>
        

        <span class="n">doehler_style</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">doehler_style</span><span class="p">:</span>
            <span class="n">l</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">lq_decomp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reduced&#39;</span><span class="p">)</span>
            <span class="n">R21</span> <span class="o">=</span> <span class="n">l</span><span class="p">[(</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">i</span><span class="p">):((</span><span class="n">num_ref_channels</span> <span class="o">+</span> <span class="n">num_analised_channels</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">:(</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">i</span><span class="p">)]</span> 
            <span class="n">P_i_ref</span> <span class="o">=</span> <span class="n">R21</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">Hankel_matrix_T</span><span class="o">.</span><span class="n">shape</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hankel shape = &#39;</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    
            <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">Hankel_matrix_T</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;economic&#39;</span><span class="p">)</span>
            <span class="c1"># Reduce Q (MxK) to Q (MXN) and R (KxN) to R (NxN), where N = total_time_steps - 2*num_block_rows</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:((</span><span class="n">num_ref_channels</span> <span class="o">+</span> <span class="n">num_analised_channels</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">:((</span><span class="n">num_ref_channels</span> <span class="o">+</span> <span class="n">num_analised_channels</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">),:])</span><span class="o">.</span><span class="n">T</span>
            
            <span class="c1">#check_I = np.dot(Q,Q.T)</span>
            <span class="c1">#new_Hankel = np.dot(R,Q)</span>
            <span class="c1">#Hankel_diff = Hankel_matrix_T - new_Hankel.T</span>
            
            <span class="c1">#R_21 = R[(num_ref_channels*i):(num_ref_channels*(i+1)),0:(num_ref_channels*i)]</span>
            <span class="c1">#R_22 = R[(num_ref_channels*i):(num_ref_channels*(i+1)),(num_ref_channels*i):(num_ref_channels*(i+1))]</span>
            <span class="c1">#R_31 = R[(num_ref_channels*(i+1)):(num_ref_channels*(i+1)+num_roving_channels),0:(num_ref_channels*i)]</span>
            <span class="c1">#R_32 = R[(num_ref_channels*(i+1)):(num_ref_channels*(i+1)+num_roving_channels),(num_ref_channels*i):(num_ref_channels*(i+1))]</span>
            <span class="c1">#R_33 = R[(num_ref_channels*(i+1)):(num_ref_channels*(i+1)+num_roving_channels),(num_ref_channels*(i+1)):(num_ref_channels*(i+1)+num_roving_channels)]</span>
            <span class="c1">#R_41 = R[(num_ref_channels*(i+1)+num_roving_channels):((num_ref_channels + num_analised_channels) * i),0:(num_ref_channels*i)]</span>
            <span class="c1">#R_42 = R[(num_ref_channels*(i+1)+num_roving_channels):((num_ref_channels + num_analised_channels) * i),(num_ref_channels*i):(num_ref_channels*(i+1))]</span>
            
            <span class="c1">#Q_1 = Q[0:(num_ref_channels*i),:]</span>
            <span class="c1">#Q_12 = Q[0:(num_ref_channels*(i+1)),:]</span>
            <span class="c1">#Q_123 = Q[0:(num_ref_channels*(i+1)+num_roving_channels),:]</span>
            <span class="n">P_i_ref</span> <span class="o">=</span> <span class="n">R</span><span class="p">[(</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">i</span><span class="p">):((</span><span class="n">num_ref_channels</span> <span class="o">+</span> <span class="n">num_analised_channels</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">:(</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">i</span><span class="p">)]</span> 
            <span class="c1">#P_i_ref = np.dot(P_i_ref, Q_1)</span>
         
        <span class="bp">self</span><span class="o">.</span><span class="n">P_i_ref</span> <span class="o">=</span> <span class="n">P_i_ref</span>              
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># previous state matrices are invalid now</span></div>
      
                       
    <span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">    def init_child_process(self, refs_memory_, measurement_memory_, toeplitz_memory_):</span>
<span class="sd">        #make the  memory arrays available to the child processes</span>
<span class="sd">        global refs_memory</span>
<span class="sd">        refs_memory = refs_memory_</span>
<span class="sd">        </span>
<span class="sd">        global measurement_memory</span>
<span class="sd">        measurement_memory = measurement_memory_   </span>
<span class="sd">        </span>
<span class="sd">        global toeplitz_memory</span>
<span class="sd">        toeplitz_memory = toeplitz_memory_</span>
<span class="sd">    &#39;&#39;&#39;</span>
        
        
<div class="viewcode-block" id="SSIData.compute_state_matrices"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.compute_state_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">compute_state_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_model_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        computes the state and output matrices A and C, resp., of the state-space-model</span>
<span class="sd">        by applying a singular value decomposition to the projection matrix P_i_ref</span>
<span class="sd">        the state space model matrices are obtained by appropriate truncation </span>
<span class="sd">        of the svd matrices at max_model_order</span>
<span class="sd">        &#39;&#39;&#39;</span>        
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="n">max_model_order</span> 
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">P_i_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_i_ref</span>              
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
           
        <span class="c1">###############################################################################</span>
        <span class="c1">############# Computation of state matrices A and C ###########################</span>
        <span class="c1">###############################################################################</span>
       
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing state matrices A and C...&#39;</span><span class="p">)</span>
        
        
        <span class="p">[</span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V_T</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">P_i_ref</span><span class="p">);</span>
        <span class="n">S_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span><span class="p">))</span> 
     
        <span class="c1"># choose highest possible model order</span>
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_model_order</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_model_order</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>       
        
        <span class="n">S_2</span><span class="o">=</span><span class="n">S_2</span><span class="p">[:</span><span class="n">max_model_order</span><span class="p">,:</span><span class="n">max_model_order</span><span class="p">]</span>
        <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">[:,:</span><span class="n">max_model_order</span><span class="p">]</span>
        <span class="n">Oi_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">S_2</span><span class="p">)</span>
        <span class="n">C_full</span><span class="o">=</span><span class="n">Oi_full</span><span class="p">[:</span><span class="n">num_analised_channels</span><span class="p">,:]</span>        
        <span class="n">A_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">Oi_full</span><span class="p">[:(</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),:]),</span>
                   <span class="n">Oi_full</span><span class="p">[</span><span class="n">num_analised_channels</span><span class="p">:(</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">),:])</span>
        
        <span class="c1">#O_i1_full = Oi_full[:((num_block_rows-1)* num_analised_channels),:]</span>
       
        <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span> <span class="o">=</span> <span class="n">A_full</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span> <span class="o">=</span> <span class="n">C_full</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="n">max_model_order</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># previous modal params are invalid now</span></div>
        

<div class="viewcode-block" id="SSIData.compute_modal_params"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.compute_modal_params">[docs]</a>    <span class="k">def</span> <span class="nf">compute_modal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_model_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiprocessing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
        
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="n">max_model_order</span> 
            
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="n">max_model_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
        <span class="n">A_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span>
        <span class="n">C_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span>
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span>
          
        <span class="c1">###############################################################################</span>
        <span class="c1">############# Computation of modal parameters #################################</span>
        <span class="c1">###############################################################################</span>
        
         
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing modal parameters...&#39;</span><span class="p">)</span>
          
        <span class="n">lambda_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>        
        <span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">modal_damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                
        <span class="sd">&#39;&#39;&#39;                 </span>
<span class="sd">        S_2 = np.diag(np.sqrt(S)) </span>
<span class="sd">        for index in range(max_model_order):    </span>
<span class="sd">            </span>
<span class="sd">            if index &gt; 1:</span>
<span class="sd">                </span>
<span class="sd">                this_S = S_2[0:index,0:index]</span>
<span class="sd">                this_U=U[:,0:index]</span>
<span class="sd">                Oi = Oi_full[:,0:index]</span>
<span class="sd">                X_i = np.dot(np.linalg.pinv(Oi), P_i_ref)</span>
<span class="sd">                O_i1 = O_i1_full[:,0:index]</span>
<span class="sd">                X_i1 = np.dot(np.linalg.pinv(O_i1), P_i_minus_1_ref)</span>
<span class="sd">                </span>
<span class="sd">                </span>
<span class="sd">                Kalman_matrix = np.zeros(((num_analised_channels + index),dim_Y_i_i[1]))</span>
<span class="sd">                Kalman_matrix[0:index,:] = X_i1</span>
<span class="sd">                Kalman_matrix[index:(num_analised_channels + index),:] = Y_i_i</span>
<span class="sd">                AC_matrix = np.dot(Kalman_matrix, np.linalg.pinv(X_i))</span>
<span class="sd">                this_A = AC_matrix[0:index, :]</span>
<span class="sd">                this_C = AC_matrix[index:(num_analised_channels + index), :]</span>
<span class="sd">                </span>
<span class="sd">                print(&#39;INDEX = &#39;, index)</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>  
        
                    
        <span class="k">if</span> <span class="n">multiprocessing</span><span class="p">:</span>
            <span class="n">manager</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>      <span class="c1">#@UndefinedVariable  </span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">()</span>       <span class="c1">#@UndefinedVariable </span>
            <span class="n">return_dict</span><span class="o">=</span><span class="n">manager</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
            
            <span class="c1">#balanced allocation of work (numpy.linalg.eig takes approx. n^3 operations)</span>
            <span class="n">work_slice_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">n</span><span class="o">**</span><span class="mi">3</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">)])</span><span class="o">/</span><span class="n">max_model_order</span>
            <span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">current_orders</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">current_orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
                <span class="n">current_size</span> <span class="o">+=</span> <span class="n">order</span><span class="o">**</span><span class="mi">3</span>
                <span class="k">if</span> <span class="n">current_size</span> <span class="o">&gt;=</span> <span class="n">work_slice_size</span><span class="p">:</span>
                    <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiprocess_evd</span> <span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">A_full</span><span class="p">,</span> <span class="n">current_orders</span><span class="p">,</span> <span class="n">return_dict</span><span class="p">))</span>
                    <span class="n">current_orders</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>


        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>    
            
            <span class="k">if</span> <span class="n">multiprocessing</span><span class="p">:</span>
                <span class="n">eigenvalues_single</span><span class="p">,</span> <span class="n">eigenvectors_single</span> <span class="o">=</span> <span class="n">return_dict</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eigenvalues_paired</span><span class="p">,</span> <span class="n">eigenvectors_paired</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A_full</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>                
                <span class="n">eigenvectors_single</span><span class="p">,</span><span class="n">eigenvalues_single</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_conjugates_new</span><span class="p">(</span><span class="n">eigenvectors_paired</span><span class="p">,</span><span class="n">eigenvalues_paired</span><span class="p">)</span>
<span class="c1">#                 ax1.plot(eigenvalues_single.real,eigenvalues_single.imag, ls=&#39;&#39;, marker=&#39;o&#39;)</span>
                
            <span class="n">lambdas</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eigenvalues_single</span><span class="p">):</span> 
                <span class="n">lambda_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="o">*</span> <span class="n">sampling_rate</span>
                <span class="n">lambdas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_k</span><span class="p">)</span>
                <span class="n">freq_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_k</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>        
                <span class="n">damping_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambda_k</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_k</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span>  
                <span class="n">mode_shapes_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C_full</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">eigenvectors_single</span><span class="p">[:,</span><span class="n">index</span><span class="p">])</span>
            
                <span class="c1"># integrate acceleration and velocity channels to level out all channels in phase and amplitude</span>
                <span class="c1">#mode_shapes_j = self.integrate_quantities(mode_shapes_j, accel_channels, velo_channels, np.abs(lambda_k))                </span>
                        
                <span class="n">modal_frequencies</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">index</span><span class="p">]</span><span class="o">=</span><span class="n">freq_j</span>
                <span class="n">modal_damping</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">index</span><span class="p">]</span><span class="o">=</span><span class="n">damping_j</span>
                <span class="n">mode_shapes</span><span class="p">[:,</span><span class="n">index</span><span class="p">,</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">mode_shapes_j</span>
            <span class="n">lambdas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lambdas</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">modal_frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="n">modal_damping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">mode_shapes</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span></div>
        
    
<div class="viewcode-block" id="SSIData.multiprocess_evd"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.multiprocess_evd">[docs]</a>    <span class="k">def</span> <span class="nf">multiprocess_evd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">truncation_orders</span><span class="p">,</span> <span class="n">return_dict</span><span class="p">):</span>
        
        <span class="k">for</span> <span class="n">truncation_order</span> <span class="ow">in</span> <span class="n">truncation_orders</span><span class="p">:</span>
            <span class="n">eigenvalues_paired</span><span class="p">,</span> <span class="n">eigenvectors_paired</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">truncation_order</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">truncation_order</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
            <span class="n">eigenvectors_single</span><span class="p">,</span><span class="n">eigenvalues_single</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_conjugates_new</span><span class="p">(</span><span class="n">eigenvectors_paired</span><span class="p">,</span><span class="n">eigenvalues_paired</span><span class="p">)</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">truncation_order</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">eigenvalues_single</span><span class="p">,</span> <span class="n">eigenvectors_single</span><span class="p">)</span>
        
        <span class="k">return</span></div>
                    
<div class="viewcode-block" id="SSIData.remove_conjugates_new"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.remove_conjugates_new">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">remove_conjugates_new</span> <span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        removes conjugates and marks the vectors which appear in pairs</span>
<span class="sd">        </span>
<span class="sd">        vectors.shape = [order+1, order+1]</span>
<span class="sd">        values.shape = [order+1,1]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">num_val</span><span class="o">=</span><span class="n">vectors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">conj_indices</span><span class="o">=</span><span class="n">deque</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_val</span><span class="p">):</span>
            <span class="n">this_vec</span><span class="o">=</span><span class="n">vectors</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">this_conj_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">this_vec</span><span class="p">)</span>
            <span class="n">this_val</span><span class="o">=</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">this_conj_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">this_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this_val</span> <span class="o">==</span> <span class="n">this_conj_val</span><span class="p">:</span> <span class="c1">#remove real eigenvalues</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_val</span><span class="p">):</span> <span class="c1">#catches unordered conjugates but takes slightly longer</span>
                <span class="k">if</span> <span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_conj_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> \
                   <span class="n">vectors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_conj_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> \
                   <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_conj_val</span><span class="p">:</span>
                    <span class="c1"># saves computation time this function gets called many times and </span>
                    <span class="c1">#numpy&#39;s np.all() function causes a lot of computation time</span>
                    <span class="n">conj_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="n">conj_indices</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">)</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">conj_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">vector</span><span class="p">,</span><span class="n">value</span></div>

    
<div class="viewcode-block" id="SSIData.integrate_quantities"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.integrate_quantities">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">integrate_quantities</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">accel_channels</span><span class="p">,</span> <span class="n">velo_channels</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="c1"># input quantities = [a, v, d]</span>
        <span class="c1"># output quantities = [d, d, d]</span>
        <span class="c1"># converts amplitude and phase</span>
        <span class="c1">#                     phase + 180; magn / omega^2</span>
        
        <span class="n">vector</span><span class="p">[</span><span class="n">accel_channels</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>       <span class="o">/</span> <span class="p">(</span><span class="n">omega</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">#                    phase + 90; magn / omega</span>
        <span class="n">vector</span><span class="p">[</span><span class="n">velo_channels</span><span class="p">]</span> <span class="o">*=</span>  <span class="mi">1</span><span class="n">j</span>        <span class="o">/</span> <span class="n">omega</span>
        
        <span class="k">return</span> <span class="n">vector</span>   </div>
    
<div class="viewcode-block" id="SSIData.save_state"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.save_state">[docs]</a>    <span class="k">def</span> <span class="nf">save_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        
        <span class="n">dirname</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
            
        <span class="c1">#             0         1           2             3</span>
        <span class="c1">#self.state= [Hankel, QR_decomp.,  State matr.,  Modal Par.]</span>
        <span class="n">out_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;self.state&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">}</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.start_time&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span>
        <span class="c1">#out_dict[&#39;self.prep_data&#39;]=self.prep_data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># Block Hankel matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Hankel_matrix_T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix_T</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># QR decomposition, Projection matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.P_i_ref&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P_i_ref</span>                          
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1"># state models</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.state_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.output_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span><span class="c1"># modal params</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span>
            
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">out_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="SSIData.load_state"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.load_state">[docs]</a>    <span class="nd">@classmethod</span> 
    <span class="k">def</span> <span class="nf">load_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Now loading previous results from  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        
        <span class="n">in_dict</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>    
        <span class="c1">#             0         1           2             3</span>
        <span class="c1">#self.state= [Hankel, QR_decomp.,  State matr.,  Modal Par.]</span>
        <span class="k">if</span> <span class="s1">&#39;self.state&#39;</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
            <span class="n">state</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.state&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="k">for</span> <span class="n">this_state</span><span class="p">,</span> <span class="n">state_string</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Block Hankel Matrix Built&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;QR Decomposition Finished&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;State Matrices Computed&#39;</span><span class="p">,</span>
                                                    <span class="s1">&#39;Modal Parameters Computed&#39;</span><span class="p">,</span>
                                                    <span class="p">]):</span>
            <span class="k">if</span> <span class="n">this_state</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">state_string</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        <span class="n">setup_name</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.start_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">setup_name</span> <span class="o">==</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        
        <span class="k">assert</span> <span class="n">start_time</span> <span class="o">==</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        <span class="c1">#prep_data = in_dict[&#39;self.prep_data&#39;].item()</span>
        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">prep_data</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># Block Hankel matrix</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">Hankel_matrix_T</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Hankel_matrix_T&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># QR decomposition, Projection matrix</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">P_i_ref</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.P_i_ref&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1"># state models</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">state_matrix</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.state_matrix&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">output_matrix</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.output_matrix&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span><span class="c1"># modal params</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span>
         
        <span class="k">return</span> <span class="n">ssi_object</span></div>
    
<div class="viewcode-block" id="SSIData.rescale_mode_shape"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIData.rescale_mode_shape">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rescale_mode_shape</span><span class="p">(</span><span class="n">modeshape</span><span class="p">):</span>
        <span class="c1">#scaling of mode shape</span>
        <span class="n">modeshape</span> <span class="o">=</span> <span class="n">modeshape</span> <span class="o">/</span> <span class="n">modeshape</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">modeshape</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">modeshape</span></div></div>
    
<div class="viewcode-block" id="SSIDataMC"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC">[docs]</a><span class="k">class</span> <span class="nc">SSIDataMC</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prep_data</span><span class="p">):</span>    
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        channel definition: channels start at 0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span> <span class="o">=</span><span class="n">prep_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        <span class="c1">#             0         1           2             3</span>
        <span class="c1">#self.state= [Hankel, QR_decomp.,  State matr.,  Modal Par.]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span>  <span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span>    <span class="kc">False</span><span class="p">,</span>     <span class="kc">False</span><span class="p">,</span>        <span class="kc">False</span><span class="p">]</span>
        
        <span class="c1">#self.num_block_columns = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix_T</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_i_ref</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_contributions</span> <span class="o">=</span> <span class="kc">None</span>
            
<div class="viewcode-block" id="SSIDataMC.init_from_config"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.init_from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">init_from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">conf_file</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">conf_file</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">conf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Number of Block-Rows:&#39;</span>
            <span class="n">num_block_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Maximum Model Order:&#39;</span>
            <span class="n">max_model_order</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Use Multiprocessing:&#39;</span>
            <span class="n">multiprocessing</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;yes&#39;</span>
        
        
        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">prep_data</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">build_block_hankel</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_state_matrices</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_modal_params</span><span class="p">(</span><span class="n">plot_</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1">#print(&#39;max_model_order = &#39;, max_model_order)</span>
        <span class="c1">#print(&#39;ssi_object.max_model_order = &#39;, ssi_object.max_model_order)</span>
        
        <span class="k">return</span> <span class="n">ssi_object</span></div>

        
<div class="viewcode-block" id="SSIDataMC.build_block_hankel"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.build_block_hankel">[docs]</a>    <span class="k">def</span> <span class="nf">build_block_hankel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Builds a Block-Hankel Matrix of the measured time series with varying time lags</span>
<span class="sd">            | &lt;- num_time samples - num_block_rows-&gt;     |_</span>
<span class="sd">            |     y_0      y_1      ...      y_(j-1)     |^</span>
<span class="sd">            |     y_1      y_2      ...      y_j         |num_block_rows (=i)*num_analised_channels</span>
<span class="sd">            |     ...      ...      ...      ...         |v</span>
<span class="sd">            |     y_(2i-1)   y_(2i)  ...     y_(2i+j-2)  |_</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">num_block_rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
            
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span><span class="o">=</span><span class="n">num_block_rows</span>
        
        <span class="n">measurement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span>
        <span class="n">total_time_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">total_time_steps</span>
        
        <span class="n">ref_channels</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">ref_channels</span><span class="p">)</span>
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span> 
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Building subspace matrix...&#39;</span><span class="p">)</span>
        
        <span class="n">q</span> <span class="o">=</span> <span class="n">num_block_rows</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">num_block_rows</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_time_steps</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
        
        <span class="n">Y_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
        <span class="n">Y_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
         
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">Y_minus</span><span class="p">[(</span><span class="n">q</span><span class="o">-</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">q</span><span class="o">-</span><span class="n">ii</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[(</span><span class="n">ii</span><span class="p">):(</span><span class="n">ii</span><span class="o">+</span><span class="n">N</span><span class="p">),</span><span class="n">ref_channels</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
         
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">Y_plus</span><span class="p">[</span><span class="n">ii</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">:(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[(</span><span class="n">q</span><span class="o">+</span><span class="n">ii</span><span class="p">):(</span><span class="n">q</span><span class="o">+</span><span class="n">ii</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
             
        <span class="n">Hankel_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Y_minus</span><span class="p">,</span><span class="n">Y_plus</span><span class="p">))</span>
         
        <span class="n">Hankel_matrix</span> <span class="o">/=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix</span> <span class="o">=</span> <span class="n">Hankel_matrix</span>
        
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span> 

        
        <span class="n">l</span> <span class="o">=</span> <span class="n">lq_decomp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">q_</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">if</span> <span class="n">q_</span><span class="p">:</span>
            <span class="n">l</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">lq_decomp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
               
        
        <span class="n">a</span> <span class="o">=</span> <span class="n">num_ref_channels</span><span class="o">*</span><span class="n">p</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">num_ref_channels</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">num_analised_channels</span><span class="o">-</span><span class="n">num_ref_channels</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">num_analised_channels</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        
        <span class="n">R_k1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:,:</span><span class="n">a</span><span class="p">]</span>
        
        <span class="n">R_21</span> <span class="o">=</span> <span class="n">R_k1</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,:]</span>
        <span class="n">R_31</span> <span class="o">=</span> <span class="n">R_k1</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">,:]</span>
        <span class="n">R_41</span> <span class="o">=</span> <span class="n">R_k1</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">,:]</span>

        <span class="n">R_k2</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:,</span><span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">]</span>
                
        <span class="n">R_22</span> <span class="o">=</span> <span class="n">R_k2</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,:]</span>        
        <span class="n">R_32</span> <span class="o">=</span> <span class="n">R_k2</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">,:]</span>    
        <span class="n">R_42</span> <span class="o">=</span> <span class="n">R_k2</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">,:]</span>      
        
        <span class="n">R_k3</span> <span class="o">=</span> <span class="n">l</span><span class="p">[:,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">]</span>
               
        <span class="n">R_33</span> <span class="o">=</span> <span class="n">R_k3</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">,:]</span>    
        
        <span class="k">if</span> <span class="n">q_</span><span class="p">:</span>
            <span class="n">Q_1_T</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">a</span><span class="p">,:]</span>
            <span class="n">Q_2_T</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,:]</span>
            <span class="n">Q_3_T</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">,:]</span>
            <span class="n">Q_4_T</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">,:]</span>

        
        <span class="bp">self</span><span class="o">.</span><span class="n">R_21</span> <span class="o">=</span> <span class="n">R_21</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R_31</span> <span class="o">=</span> <span class="n">R_31</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R_41</span> <span class="o">=</span> <span class="n">R_41</span>
 
        <span class="bp">self</span><span class="o">.</span><span class="n">R_22</span> <span class="o">=</span> <span class="n">R_22</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R_32</span> <span class="o">=</span> <span class="n">R_32</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R_42</span> <span class="o">=</span> <span class="n">R_42</span>
         
        <span class="bp">self</span><span class="o">.</span><span class="n">R_33</span> <span class="o">=</span> <span class="n">R_33</span>    
        
<span class="c1">#         assert (self.R_21 == R_21).all()</span>
<span class="c1">#         assert (self.R_31 == R_31).all()</span>
<span class="c1">#         assert (self.R_41 == R_41).all()</span>
<span class="c1"># </span>
<span class="c1">#         assert (self.R_22 == R_22).all()</span>
<span class="c1">#         assert (self.R_32 == R_32).all()</span>
<span class="c1">#         assert (self.R_42 == R_42).all()</span>
<span class="c1">#         </span>
<span class="c1">#         assert (self.R_33 == R_33).all()  </span>
        
        <span class="k">if</span> <span class="n">q_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q_1_T</span> <span class="o">=</span> <span class="n">Q_1_T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q_2_T</span> <span class="o">=</span> <span class="n">Q_2_T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q_3_T</span> <span class="o">=</span> <span class="n">Q_3_T</span>
            <span class="c1">#self.Q_4_T = Q_4_T</span>
         
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span></div>
<span class="c1">#         self.state[1] = False # previous state matrices are invalid now</span>

        
        
<div class="viewcode-block" id="SSIDataMC.compute_state_matrices"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.compute_state_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">compute_state_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_model_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        computes the state and output matrices A and C, resp., of the state-space-model</span>
<span class="sd">        by applying a singular value decomposition to the projection matrix P_i_ref</span>
<span class="sd">        the state space model matrices are obtained by appropriate truncation </span>
<span class="sd">        of the svd matrices at max_model_order</span>
<span class="sd">        &#39;&#39;&#39;</span>        
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        
        <span class="n">R_21</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_21</span>
        <span class="n">R_31</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_31</span>
        <span class="n">R_41</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_41</span>
        <span class="n">use_q</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">if</span> <span class="n">use_q</span><span class="p">:</span>  
            <span class="c1"># somewhere it is written, that Q can be ommitted since multiplication with q only transforms the subspace into a similar subspace (or something like that)</span>
            <span class="c1"># it was tried with different data sets and equal results were obtained regarding the stable modes</span>
            <span class="n">Q_1_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_1_T</span> 
            <span class="n">P_i_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">R_21</span><span class="p">,</span><span class="n">R_31</span><span class="p">,</span><span class="n">R_41</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q_1_T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P_i_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">R_21</span><span class="p">,</span><span class="n">R_31</span><span class="p">,</span><span class="n">R_41</span><span class="p">))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing state matrices A and C...&#39;</span><span class="p">)</span>

        <span class="p">[</span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V_T</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">P_i_ref</span><span class="p">)</span>
        
        <span class="c1">#print(P_i_ref.shape)</span>
        <span class="c1">#print(U.shape)</span>
        <span class="c1">#print(S.shape)</span>
        <span class="c1">#print(V_T.shape)</span>
        
     
        <span class="c1"># choose highest possible model order</span>
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_model_order</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_model_order</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>       
        
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:</span><span class="n">max_model_order</span><span class="p">]</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:</span><span class="n">num_analised_channels</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">),:</span><span class="n">max_model_order</span><span class="p">]</span>
        <span class="n">V_T</span> <span class="o">=</span> <span class="n">V_T</span><span class="p">[:</span><span class="n">max_model_order</span><span class="p">,:]</span>
        
        <span class="c1">#print(U.shape)</span>
        <span class="c1">#print(S.shape)</span>
        <span class="c1">#print(V_T.shape)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">U</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span> <span class="o">=</span> <span class="n">V_T</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="n">max_model_order</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># previous modal params are invalid now</span></div>
        
<div class="viewcode-block" id="SSIDataMC.compute_modal_params"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.compute_modal_params">[docs]</a>    <span class="k">def</span> <span class="nf">compute_modal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_</span><span class="o">=</span><span class="kc">False</span>  <span class="p">):</span> 
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        c.p.    DeCock 2007 Subspace Identification Methods (estimation algo 1) -&gt; with noisy data unstable, fast</span>
<span class="sd">                Peeters 1999 Reference Based Stochastic Subspace Identificaiton for Ouput-Only Modal Analysis (estimation algo 2) -&gt; stable, slow</span>
<span class="sd">                estimation_algo 0 for reference</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">estimation_algo</span><span class="o">=</span><span class="mi">2</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">max_model_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span>
        <span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="n">total_time_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">total_time_steps</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_time_steps</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">num_block_rows</span><span class="p">)</span>
        
        <span class="n">R_21</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_21</span>
        <span class="n">R_31</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_31</span>
        <span class="n">R_41</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_41</span>
    
        <span class="n">R_22</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_22</span>
        <span class="n">R_32</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_32</span>
        <span class="n">R_42</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_42</span>

        <span class="n">R_33</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_33</span>
        
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="n">S_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">V_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span>
        
        <span class="n">O</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)))</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing modal parameters...&#39;</span><span class="p">)</span>
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">modal_damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">modal_contributions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>


        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">):</span>    
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
            
            <span class="n">V</span> <span class="o">=</span> <span class="n">V_T</span><span class="p">[:</span><span class="n">order</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>
            
            <span class="c1"># usually used equation computation of A, C</span>
            
            <span class="k">if</span> <span class="n">estimation_algo</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                
                <span class="n">On_up</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
                <span class="n">On_upi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up</span><span class="p">)</span>
                
                <span class="n">On_down</span> <span class="o">=</span> <span class="n">O</span><span class="p">[</span><span class="n">num_analised_channels</span><span class="p">:</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,:</span><span class="n">order</span><span class="p">]</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">On_upi</span><span class="p">,</span> <span class="n">On_down</span><span class="p">)</span>
                <span class="n">C</span><span class="o">=</span><span class="n">O</span><span class="p">[:</span><span class="n">num_analised_channels</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>  
                
            <span class="k">elif</span> <span class="n">estimation_algo</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#direct computation of A, C, Q, R and S (DeCock 2007)</span>
                
                <span class="n">On_up</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
                <span class="n">On_upi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up</span><span class="p">)</span>
                <span class="n">QSR1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">On_upi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_41</span><span class="p">),</span> <span class="n">On_upi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_42</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="p">,</span><span class="n">num_analised_channels</span><span class="o">-</span><span class="n">num_ref_channels</span><span class="p">))]),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">R_21</span><span class="p">,</span>           <span class="n">R_22</span><span class="p">,</span>          <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_ref_channels</span><span class="p">,</span> <span class="n">num_analised_channels</span><span class="o">-</span><span class="n">num_ref_channels</span><span class="p">))]),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">R_31</span><span class="p">,</span>           <span class="n">R_32</span><span class="p">,</span>            <span class="n">R_33</span><span class="p">])])</span>
                
                <span class="n">VVT</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">-</span><span class="n">V</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
                <span class="n">QSR2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">VVT</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="n">num_analised_channels</span><span class="p">))]),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_rows</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_analised_channels</span><span class="p">)]),])</span>
    
                
                <span class="n">QSR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span><span class="o">*</span><span class="n">QSR1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">QSR2</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">QSR1</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    
                <span class="n">Q</span> <span class="o">=</span> <span class="n">QSR</span><span class="p">[:</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">QSR</span><span class="p">[:</span><span class="n">order</span><span class="p">,</span><span class="n">order</span><span class="p">:</span><span class="n">order</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">]</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">QSR</span><span class="p">[</span><span class="n">order</span><span class="p">:</span><span class="n">order</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="n">order</span><span class="p">:</span><span class="n">order</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">]</span>
                <span class="n">AC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">On_upi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_41</span><span class="p">),</span><span class="n">R_21</span><span class="p">,</span><span class="n">R_31</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S_2</span><span class="p">[:</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]))</span>
                
                <span class="n">A</span><span class="o">=</span><span class="n">AC</span><span class="p">[:</span><span class="n">order</span><span class="p">,:]</span>
                <span class="n">C</span><span class="o">=</span><span class="n">AC</span><span class="p">[</span><span class="n">order</span><span class="p">:,:]</span>
                
            <span class="k">elif</span> <span class="n">estimation_algo</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># residual-based computation of Q, R  and S (Peeters 1999)</span>
                <span class="n">Q_1_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_1_T</span>
                <span class="n">Q_2_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_2_T</span>
                <span class="n">Q_3_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_3_T</span>
                <span class="c1">#Q_4_T = self.Q_4_T    </span>
                 
                <span class="n">P_i_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">R_41</span><span class="p">,</span> <span class="n">R_42</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Q_1_T</span><span class="p">,</span><span class="n">Q_2_T</span><span class="p">)))</span>
                <span class="n">O_i_1</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_analised_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
                <span class="n">O_i</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:,:</span><span class="n">order</span><span class="p">]</span>
                 
                <span class="n">Y_i_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">R_21</span><span class="p">,</span> <span class="n">R_22</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_ref_channels</span><span class="p">,</span> <span class="n">num_analised_channels</span><span class="o">-</span><span class="n">num_ref_channels</span><span class="p">))]),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">R_31</span><span class="p">,</span><span class="n">R_32</span><span class="p">,</span> <span class="n">R_33</span><span class="p">])])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Q_1_T</span><span class="p">,</span> <span class="n">Q_2_T</span><span class="p">,</span> <span class="n">Q_3_T</span><span class="p">)))</span>
                 
                <span class="n">P_i_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">R_21</span><span class="p">,</span><span class="n">R_31</span><span class="p">,</span><span class="n">R_41</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q_1_T</span><span class="p">)</span>
                 
                <span class="n">X_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">O_i</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P_i_ref</span><span class="p">)</span>
                <span class="n">X_i_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">O_i_1</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P_i_1</span><span class="p">)</span>
                 
                <span class="n">X_i_1_Y_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_i_1</span><span class="p">,</span> <span class="n">Y_i_i</span><span class="p">))</span>
                 
                <span class="n">AC</span> <span class="o">=</span> <span class="n">X_i_1_Y_i</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">X_i</span><span class="p">))</span>
                <span class="n">A</span><span class="o">=</span> <span class="n">AC</span><span class="p">[:</span><span class="n">order</span><span class="p">,:]</span>
                <span class="n">C</span><span class="o">=</span> <span class="n">AC</span><span class="p">[</span><span class="n">order</span><span class="p">:,:]</span>
                 
                <span class="n">roh_w_v</span> <span class="o">=</span> <span class="n">X_i_1_Y_i</span><span class="o">-</span><span class="n">AC</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X_i</span><span class="p">)</span>
                 
                <span class="n">QSR</span> <span class="o">=</span> <span class="n">roh_w_v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">roh_w_v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                     
                <span class="n">Q</span> <span class="o">=</span> <span class="n">QSR</span><span class="p">[:</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">QSR</span><span class="p">[:</span><span class="n">order</span><span class="p">,</span><span class="n">order</span><span class="p">:</span><span class="n">order</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">]</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">QSR</span><span class="p">[</span><span class="n">order</span><span class="p">:</span><span class="n">order</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="n">order</span><span class="p">:</span><span class="n">order</span><span class="o">+</span><span class="n">num_analised_channels</span><span class="p">]</span>
            
            
            <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            
            <span class="n">conj_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_conjugates_new</span><span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">,</span><span class="n">inds_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">):</span>
                
                <span class="n">lambda_i</span> <span class="o">=</span><span class="n">eigval</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                <span class="n">eigenvalues</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">lambda_i</span>
                <span class="c1">#continue</span>
                <span class="n">a_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">)))</span>
                <span class="n">b_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">))</span>
                <span class="n">freq_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sampling_rate</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">damping_i</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">ind</span><span class="p">])</span>
                <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                
                <span class="c1"># integrate acceleration and velocity channels to level out all channels in phase and amplitude</span>
                <span class="c1">#mode_shapes_j = self.integrate_quantities(mode_shapes_j, accel_channels, velo_channels, np.abs(lambda_k))                </span>
                        
                <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">))</span>
                <span class="n">s_ik</span> <span class="o">=</span> <span class="n">mode_shape_i</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">alpha_ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span>
                <span class="n">e_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">e_k</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">mode_shape_i</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">alpha_ik</span><span class="p">)</span>
                
                <span class="n">modal_frequencies</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">freq_i</span>
                <span class="n">modal_damping</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">damping_i</span>
                <span class="n">mode_shapes</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">mode_shape_i</span>
                
                
                
            <span class="k">if</span> <span class="n">estimation_algo</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_discrete_are</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">balanced</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Correlations of residuals are not symmetric. Skiping Modal Contributions&#39;</span><span class="p">)</span>
                <span class="k">continue</span>
<span class="c1">#                 try:</span>
<span class="c1">#                     Q = (Q + Q.T)*0.5</span>
<span class="c1">#                     R = (R + R.T)*0.5</span>
<span class="c1">#                     P = scipy.linalg.solve_discrete_are(a=A.T, b=C.T, q=Q, r=R, s=S, balanced=True)</span>
<span class="c1">#                 except Exception as e:</span>
<span class="c1">#                     print(&#39;Can not estimate Kalman Gain at order {}. Skipping Modal Contributions!&#39;.format(order))</span>
<span class="c1">#                     #print(e)</span>
<span class="c1">#                     continue</span>
                
                
            <span class="n">APCS</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">S</span>
            <span class="n">CPCR</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">R</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span> <span class="n">CPCR</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">APCS</span><span class="o">.</span><span class="n">T</span><span class="p">,)</span><span class="o">.</span><span class="n">T</span>
            
            
            
            <span class="n">A_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">eigval</span><span class="p">)</span>
            <span class="n">C_0</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eigvec_r</span><span class="p">)</span>
            <span class="n">K_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">eigvec_r</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
            
            <span class="n">j</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#j=12000</span>
            <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>

            
            <span class="n">AKC</span> <span class="o">=</span> <span class="p">(</span><span class="n">A_0</span><span class="o">-</span><span class="n">K_0</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C_0</span><span class="p">))</span>
            <span class="n">AKC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">AKC</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>

            <span class="n">K_0m</span> <span class="o">=</span> <span class="n">K_0</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span><span class="p">[:</span><span class="n">j</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">K_0m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">K_0m</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
            <span class="k">global</span> <span class="n">use_cython</span>
            <span class="k">if</span> <span class="n">use_cython</span><span class="p">:</span>
                <span class="n">states</span> <span class="o">=</span> <span class="n">estimate_states</span><span class="p">(</span><span class="n">AKC</span><span class="p">,</span> <span class="n">K_0m</span><span class="p">)</span><span class="c1">#@UndefinedVariable</span>
            <span class="k">else</span><span class="p">:</span>
                
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
     
                    <span class="n">states</span><span class="p">[:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">K_0m</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">AKC</span><span class="p">,</span> <span class="n">states</span><span class="p">[:,</span><span class="n">k</span><span class="p">])</span>


            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span><span class="p">[:</span><span class="n">j</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,ji-&gt;j&#39;</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>
            
            
            <span class="n">meas_synth_single</span> <span class="o">=</span> <span class="p">[]</span>    
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">):</span>
                
                <span class="n">lambda_i</span> <span class="o">=</span><span class="n">eigval</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                
                <span class="n">ident</span> <span class="o">=</span> <span class="n">eigval</span> <span class="o">==</span> <span class="n">lambda_i</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="n">ident</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>                
                <span class="n">ident</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span>
                
                <span class="n">C_0I</span><span class="o">=</span><span class="n">C_0</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span>
                
                <span class="n">meas_synth</span> <span class="o">=</span> <span class="n">C_0I</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
                <span class="n">meas_synth</span> <span class="o">=</span> <span class="n">meas_synth</span><span class="o">.</span><span class="n">real</span>
                <span class="n">meas_synth_single</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meas_synth</span><span class="p">)</span>

                <span class="n">mYT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,ji-&gt;j&#39;</span><span class="p">,</span> <span class="n">meas_synth</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>
                
                <span class="n">modal_contributions</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">norm</span><span class="o">*</span><span class="n">mYT</span><span class="p">)</span>
                
                
                
            <span class="c1">#print(np.sum(modal_contributions[order,:]))</span>
            <span class="n">plot_</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">if</span> <span class="n">plot_</span> <span class="ow">and</span> <span class="n">order</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">modal_contributions</span><span class="p">[</span><span class="n">order</span><span class="p">,:][</span><span class="n">modal_contributions</span><span class="p">[</span><span class="n">order</span><span class="p">,:]</span><span class="o">!=</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">modal_contributions</span><span class="p">[</span><span class="n">order</span><span class="p">,:]))</span>
                <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plot</span>
<span class="c1">#                 axes=[]</span>
<span class="c1">#                 for i in range(len(conj_indices)):</span>
<span class="c1">#                     plot.figure()</span>
<span class="c1">#                     plot.plot(meas_synth_single[i][0,500:1000])</span>
<span class="c1">#                     ax=plot.gca()</span>
<span class="c1">#                     ax.set_xlim((0,500))</span>
<span class="c1">#                     ax.set_ylim((-0.0015,0.0015))</span>
<span class="c1">#                     ax.set_xticklabels([])</span>
<span class="c1">#                     ax.set_yticklabels([])</span>
<span class="c1">#                 plot.figure()</span>
<span class="c1">#                 plot.plot(self.prep_data.measurement[500:1000,0])</span>
<span class="c1">#                 ax=plot.gca()</span>
<span class="c1">#                 ax.set_xlim((0,500))</span>
<span class="c1">#                 ax.set_ylim((-0.0015,0.0015))</span>
<span class="c1">#                 ax.set_xticklabels([])</span>
<span class="c1">#                 ax.set_yticklabels([])</span>
<span class="c1">#                 plot.show()</span>
                
                <span class="n">fig</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="n">plot</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="s1">&#39;col&#39;</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="s1">&#39;col&#39;</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1">#print(axes)</span>
                <span class="n">j4</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">4</span><span class="p">))</span>
                <span class="n">ft_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">j4</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">))</span>    
                <span class="n">meas_synth_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">),</span><span class="n">meas_synth</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">meas_synth_single</span><span class="p">):</span>
                    <span class="c1">#print(ax1,ax2, axes)</span>
                    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">meas_synth</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="n">j</span><span class="p">])</span>
                    
                    <span class="n">ft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">meas_synth</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="n">j4</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">j4</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                        <span class="n">ft</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">meas_synth</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="n">j4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">j4</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">j4</span><span class="p">))</span>
                    <span class="n">ft</span> <span class="o">/=</span> <span class="mi">4</span>   
                      
                    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ft_freq</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ft</span><span class="p">))</span>
                    <span class="n">meas_synth_all</span><span class="o">+=</span><span class="n">meas_synth</span>
      
                <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">alpha</span><span class="o">=.</span><span class="mi">5</span><span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">meas_synth_all</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="n">j</span><span class="p">])</span>
                <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">meas_synth_all</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span><span class="p">[:</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">alpha</span><span class="o">=.</span><span class="mi">25</span><span class="p">)</span>
                <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="c1">#ft_freq = np.fft.rfftfreq(j/4, d = (1/self.prep_data.sampling_rate))</span>
                  
                <span class="n">ft_meas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">j4</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">ft_meas</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">j4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">j4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">j4</span><span class="p">))</span>
                <span class="n">ft_meas</span> <span class="o">/=</span> <span class="mi">4</span>               
                <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ft_freq</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ft_meas</span><span class="p">),</span><span class="n">alpha</span><span class="o">=.</span><span class="mi">5</span><span class="p">)</span>
                  
                <span class="n">ft_synth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">meas_synth_all</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="n">j4</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">j4</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">ft_synth</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">meas_synth_all</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="o">*</span><span class="n">j4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">j4</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">j4</span><span class="p">))</span>
                <span class="n">ft_synth</span> <span class="o">/=</span> <span class="mi">4</span>   
                <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ft_freq</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ft_synth</span><span class="p">))</span>
                
                <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
                  
                <span class="n">plot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_contributions</span> <span class="o">=</span> <span class="n">modal_contributions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">modal_frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="n">modal_damping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">mode_shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">eigenvalues</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  </div>
    
<div class="viewcode-block" id="SSIDataMC.remove_conjugates_new"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.remove_conjugates_new">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">remove_conjugates_new</span> <span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">,</span> <span class="n">eigvec_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inds_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        finds and removes conjugates</span>
<span class="sd">        keeps the second occurance of a conjugate pair (usually the one with the negative imaginary part)</span>
<span class="sd">        </span>
<span class="sd">        eigvec_l.shape = [order+1, order+1]</span>
<span class="sd">        eigval.shape = [order+1,1]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#return vectors, eigval</span>
        <span class="n">num_val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">eigval</span><span class="p">)</span>
        <span class="n">conj_indices</span><span class="o">=</span><span class="n">deque</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_val</span><span class="p">):</span>
            <span class="n">this_val</span><span class="o">=</span><span class="n">eigval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">this_conj_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">this_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this_val</span> <span class="o">==</span> <span class="n">this_conj_val</span><span class="p">:</span> <span class="c1">#remove real eigvals</span>
                <span class="c1">#continue</span>
                <span class="n">conj_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_val</span><span class="p">):</span> <span class="c1">#catches unordered conjugates but takes slightly longer</span>
                <span class="k">if</span> <span class="n">eigval</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_conj_val</span><span class="p">:</span>

                    <span class="n">conj_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="n">conj_indices</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_val</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">inds_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conj_indices</span>
        
        <span class="k">if</span> <span class="n">eigvec_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            
            <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
            <span class="n">eigval</span> <span class="o">=</span> <span class="n">eigval</span><span class="p">[</span><span class="n">conj_indices</span><span class="p">]</span>
    
            <span class="k">return</span> <span class="n">eigval</span><span class="p">,</span><span class="n">eigvec_r</span>      
        
        <span class="k">else</span><span class="p">:</span>             
            <span class="n">eigvec_l</span> <span class="o">=</span> <span class="n">eigvec_l</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
            <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
            <span class="n">eigval</span> <span class="o">=</span> <span class="n">eigval</span><span class="p">[</span><span class="n">conj_indices</span><span class="p">]</span>
    
            <span class="k">return</span> <span class="n">eigval</span><span class="p">,</span><span class="n">eigvec_l</span><span class="p">,</span><span class="n">eigvec_r</span>      </div>

    
<div class="viewcode-block" id="SSIDataMC.integrate_quantities"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.integrate_quantities">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">integrate_quantities</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">accel_channels</span><span class="p">,</span> <span class="n">velo_channels</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="c1"># input quantities = [a, v, d]</span>
        <span class="c1"># output quantities = [d, d, d]</span>
        <span class="c1"># converts amplitude and phase</span>
        <span class="c1">#                     phase + 180; magn / omega^2</span>
        
        <span class="n">vector</span><span class="p">[</span><span class="n">accel_channels</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>       <span class="o">/</span> <span class="p">(</span><span class="n">omega</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">#                    phase + 90; magn / omega</span>
        <span class="n">vector</span><span class="p">[</span><span class="n">velo_channels</span><span class="p">]</span> <span class="o">*=</span>  <span class="mi">1</span><span class="n">j</span>        <span class="o">/</span> <span class="n">omega</span>
        
        <span class="k">return</span> <span class="n">vector</span>   </div>
    
<div class="viewcode-block" id="SSIDataMC.save_state"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.save_state">[docs]</a>    <span class="k">def</span> <span class="nf">save_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving results to  </span><span class="si">{}</span><span class="s1">...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        
        <span class="n">dirname</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
            
        <span class="n">out_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;self.state&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">}</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.start_time&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span>
        <span class="c1">#out_dict[&#39;self.prep_data&#39;]=self.prep_data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># subspace matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Hankel_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hankel_matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.R_21&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_21</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.R_31&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_31</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.R_41&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_41</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.R_22&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_22</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.R_32&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_32</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.R_42&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_42</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.R_33&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_33</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Q_1_T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_1_T</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Q_2_T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_2_T</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Q_3_T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_3_T</span>
            <span class="c1">#out_dict[&#39;self.Q_4_T&#39;] = self.Q_4_T</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># singular value decomposition / state matrices</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.S&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.U&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.V_T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span>              
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1"># modal params</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.eigenvalues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_contributions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_contributions</span>
            
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">out_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="SSIDataMC.load_state"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.load_state">[docs]</a>    <span class="nd">@classmethod</span> 
    <span class="k">def</span> <span class="nf">load_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Now loading previous results from  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        
        <span class="n">in_dict</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    
        <span class="c1">#             0         1           2             3</span>
        <span class="c1">#self.state= [Hankel, QR_decomp.,  State matr.,  Modal Par.]</span>
        <span class="k">if</span> <span class="s1">&#39;self.state&#39;</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
            <span class="n">state</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.state&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        

        
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        <span class="n">setup_name</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.start_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">setup_name</span> <span class="o">==</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        
        <span class="k">assert</span> <span class="n">start_time</span> <span class="o">==</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        <span class="c1">#prep_data = in_dict[&#39;self.prep_data&#39;].item()</span>
        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">prep_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># subspace matrix</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Subspace Matrix Built&#39;</span><span class="p">)</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">Hankel_matrix</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Hankel_matrix&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">R_21</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.R_21&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">R_31</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.R_31&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">R_41</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.R_41&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">R_22</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.R_22&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">R_32</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.R_32&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">R_42</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.R_42&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">R_33</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.R_33&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;self.Q_1_T&#39;</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">Q_1_T</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Q_1_T&#39;</span><span class="p">]</span> 
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">Q_2_T</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Q_2_T&#39;</span><span class="p">]</span> 
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">Q_3_T</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Q_3_T&#39;</span><span class="p">]</span> 
                <span class="c1">#ssi_object.Q_4_T= in_dict[&#39;self.Q_4_T&#39;] </span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># singular value decomposition / state matrices</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;State Matrices Computed&#39;</span><span class="p">)</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">max_model_order</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">S</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.S&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">U</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.U&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">V_T</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.V_T&#39;</span><span class="p">]</span>            
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1"># modal params</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Modal Parameters Computed&#39;</span><span class="p">)</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_frequencies</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_damping</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">mode_shapes</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_contributions</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_contributions&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;self.eigenvalues&#39;</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.eigenvalues&#39;</span><span class="p">]</span> 
                
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">return</span> <span class="n">ssi_object</span></div>
    
<div class="viewcode-block" id="SSIDataMC.rescale_mode_shape"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.SSIDataMC.rescale_mode_shape">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rescale_mode_shape</span><span class="p">(</span><span class="n">modeshape</span><span class="p">):</span>
        <span class="c1">#scaling of mode shape</span>
        <span class="n">modeshape</span> <span class="o">=</span> <span class="n">modeshape</span> <span class="o">/</span> <span class="n">modeshape</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">modeshape</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">modeshape</span>    </div></div>
<div class="viewcode-block" id="main"><a class="viewcode-back" href="../classes/SSIData.html#SSIData.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>   
    
    <span class="k">pass</span></div>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">use_cython</span> 
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">pyximport</span>
        <span class="n">pyximport</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="n">setup_args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;include_dirs&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">get_include</span><span class="p">()})</span>
        <span class="kn">from</span> <span class="nn">cython_code.cython_helpers</span> <span class="kn">import</span> <span class="n">estimate_states</span><span class="c1">#@UnresolvedImport</span>
        <span class="n">use_cython</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not using Cython extensions. Python based state estimation possibly errorneous/untested&#39;</span><span class="p">)</span>
        <span class="c1">#global use_cython</span>
        <span class="n">use_cython</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Simon Marwitz, Volkmar Zabel, Andrei Udrea.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>