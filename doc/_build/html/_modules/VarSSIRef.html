

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>VarSSIRef &mdash; pyOMA  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pyOMA
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyOMA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>VarSSIRef</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for VarSSIRef</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Based on previous works by Andrei Udrea 2014 and Volkmar Zabel 2015</span>
<span class="sd">Modified and Extended by Simon Marwitz 2015/2016/2017</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> 
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">ctypes</span> <span class="k">as</span> <span class="nn">c</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="kn">from</span> <span class="nn">PreprocessingTools</span> <span class="kn">import</span> <span class="n">PreprocessData</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">TODO:</span>
<span class="sd">- define unit tests to check functionality after changes</span>
<span class="sd">- optimize multi order qr-based estimation routine</span>
<span class="sd">- iterate over conjugate indices instead of removing them --&gt; SSI_Data MC</span>
<span class="sd">- add mode-shape integration with variances</span>
<span class="sd">- use monte-carlo sampling in the last step of variance propagation (see: https://doi.org/10.1007/978-3-7091-0399-9_3)</span>
<span class="sd">&#39;&#39;&#39;</span>
    
<div class="viewcode-block" id="vectorize"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.vectorize">[docs]</a><span class="k">def</span> <span class="nf">vectorize</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        | 1  2  3 |</span>
<span class="sd">    A=  | 4  5  6 |</span>
<span class="sd">        | 7  8  9 |</span>
<span class="sd">        </span>
<span class="sd">    returns vertically stacked columns of matrix A</span>
<span class="sd">        </span>
<span class="sd">    | 1 |</span>
<span class="sd">    | 4 |</span>
<span class="sd">    | 7 |</span>
<span class="sd">    | 2 |</span>
<span class="sd">    | 5 |</span>
<span class="sd">    | 8 |</span>
<span class="sd">    | 3 |</span>
<span class="sd">    | 6 |</span>
<span class="sd">    | 9 |</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">matrix</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span><span class="s1">&#39;F&#39;</span><span class="p">)</span></div>

<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>

<div class="viewcode-block" id="permutation"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.permutation">[docs]</a><span class="k">def</span> <span class="nf">permutation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">))</span><span class="c1">#zeros((a*b,a*b))     </span>
    <span class="n">ind1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">))</span><span class="c1">#range(a*b)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">ind2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">ind1</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#mod(ind1*a,a*b-1)</span>
    <span class="n">ind2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span> <span class="c1">#a*b-1</span>
    <span class="n">P</span><span class="p">[</span><span class="n">ind1</span><span class="p">,</span><span class="n">ind2</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="rq_decomp"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.rq_decomp">[docs]</a><span class="k">def</span> <span class="nf">rq_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">q</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="ql_decomp"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.ql_decomp">[docs]</a><span class="k">def</span> <span class="nf">ql_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="dot"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.dot">[docs]</a><span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="lq_decomp"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.lq_decomp">[docs]</a><span class="k">def</span> <span class="nf">lq_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    a: array_like, shape (M,N)</span>
<span class="sd">    l: (M,K)</span>
<span class="sd">    q: (K,N)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="n">r</span><span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fact</span><span class="p">,(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
            <span class="n">q</span><span class="o">*=</span> <span class="n">fact</span>
            <span class="c1">#print(np.allclose(a.T,q.dot(r)))</span>
            
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="VarSSIRef"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef">[docs]</a><span class="k">class</span> <span class="nc">VarSSIRef</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prep_data</span><span class="p">):</span>    
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        channel definition: channels start at 0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span> <span class="o">=</span><span class="n">prep_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        <span class="c1">#             0         1           2         </span>
        <span class="c1">#self.state= [Hankel, State Mat., Modal Par.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span>  <span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span>    <span class="kc">False</span><span class="p">,</span>      <span class="kc">False</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">=</span> <span class="s1">&#39;pinv&#39;</span><span class="c1"># &#39;qr&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">=</span> <span class="s1">&#39;fast&#39;</span><span class="c1"># &#39;slow&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="kc">None</span>
            
<div class="viewcode-block" id="VarSSIRef.init_from_config"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.init_from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">init_from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">conf_file</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">conf_file</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">conf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Number of Block-Columns:&#39;</span>
            <span class="n">num_block_columns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Maximum Model Order:&#39;</span>
            <span class="n">max_model_order</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Use Multiprocessing:&#39;</span>
            <span class="n">multiprocessing</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;yes&#39;</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Number of Blocks:&#39;</span>
            <span class="n">num_blocks</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="o">.</span> <span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>            
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Subspace Method (projection/covariance):&#39;</span>
            <span class="n">subspace_method</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>   
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;LSQ Method for A (pinv/qr):&#39;</span>
            <span class="n">lsq_method</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>         
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">==</span> <span class="s1">&#39;Variance Algorithm (fast/slow):&#39;</span>
            <span class="n">variance_algo</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            
        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">prep_data</span><span class="p">)</span>    

        <span class="n">ssi_object</span><span class="o">.</span><span class="n">build_subspace_mat</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">,</span> <span class="n">multiprocess</span><span class="o">=</span><span class="n">multiprocessing</span><span class="p">,</span> <span class="n">num_blocks</span><span class="o">=</span><span class="n">num_blocks</span><span class="p">,</span> <span class="n">subspace_method</span><span class="o">=</span><span class="n">subspace_method</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_state_matrices</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">lsq_method</span><span class="o">=</span><span class="n">lsq_method</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">prepare_sensitivities</span><span class="p">(</span><span class="n">variance_algo</span><span class="o">=</span><span class="n">variance_algo</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">compute_modal_params</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">ssi_object</span></div>
     
<div class="viewcode-block" id="VarSSIRef.build_subspace_mat"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.build_subspace_mat">[docs]</a>    <span class="k">def</span> <span class="nf">build_subspace_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="p">,</span> <span class="n">num_block_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiprocess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_blocks</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">subspace_method</span><span class="o">=</span><span class="s1">&#39;covariance&#39;</span><span class="p">):</span>
        
        <span class="k">assert</span> <span class="n">multiprocess</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Builds a Block-Hankel Matrix of Covariances with varying time lags</span>
<span class="sd">        </span>
<span class="sd">            |    R_i    R_i-1    ...    R_1    |</span>
<span class="sd">            |    R_i+1  R_i      ...    R_2    |</span>
<span class="sd">            |    ...    ...      ...    ...    |</span>
<span class="sd">            |    R_2i-1 ...      ...    R_i    |</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#print(multiprocess)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_block_rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_block_rows</span><span class="o">=</span><span class="n">num_block_columns</span><span class="c1">#-10</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_block_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">subspace_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;covariance&#39;</span><span class="p">,</span> <span class="s1">&#39;projection&#39;</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Building subspace matrices with </span><span class="si">{}</span><span class="s1">-based method...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subspace_method</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span><span class="o">=</span><span class="n">num_block_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span><span class="o">=</span><span class="n">num_block_rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_blocks</span><span class="o">=</span><span class="n">num_blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">=</span> <span class="n">subspace_method</span>
        
        <span class="n">total_time_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">total_time_steps</span>
        <span class="n">ref_channels</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">ref_channels</span><span class="p">)</span>
        <span class="c1">#roving_channels = self.prep_data.roving_channels</span>
        <span class="n">measurement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">measurement</span>
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span> 

        
        <span class="n">all_channels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_analised_channels</span><span class="p">))</span><span class="c1">#ref_channels + roving_channels</span>
        <span class="c1">#all_channels.sort()</span>
        
        <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
            <span class="n">block_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">total_time_steps</span><span class="o">/</span><span class="n">num_blocks</span><span class="p">))</span>
            <span class="n">tau_max</span> <span class="o">=</span> <span class="n">num_block_columns</span><span class="o">+</span><span class="n">num_block_rows</span>
            <span class="k">if</span> <span class="n">block_length</span> <span class="o">&lt;=</span> <span class="n">tau_max</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Block length (=</span><span class="si">{}</span><span class="s1">) must be greater or equal to max time lag (=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block_length</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">))</span>
            <span class="c1">#extract_length = block_length - tau_max</span>

            <span class="n">corr_matrices_mem</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="n">corr_mats_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau_max</span> <span class="o">*</span> <span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">num_ref_channels</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
                <span class="n">corr_memory</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">corr_mats_shape</span><span class="p">))))</span> <span class="c1"># shared memory, can be used by multiple processes @UndefinedVariable</span>
                <span class="n">corr_matrices_mem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_memory</span><span class="p">)</span>
                
            <span class="c1">#measurement*=float(np.sqrt(block_length))</span>
            <span class="n">measurement_shape</span><span class="o">=</span><span class="n">measurement</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">measurement_memory</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c_double</span><span class="p">,</span> <span class="n">measurement</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">measurement</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="c1"># @UndefinedVariable</span>
                    
            <span class="c1">#each process should have at least 10 blocks to compute, to reduce overhead associated with spawning new processes </span>
            <span class="n">n_proc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tau_max</span><span class="o">*</span><span class="n">num_blocks</span><span class="o">/</span><span class="mi">10</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())</span>
            <span class="n">pool</span><span class="o">=</span><span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">n_proc</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init_child_process</span><span class="p">,</span> <span class="n">initargs</span><span class="o">=</span><span class="p">(</span><span class="n">measurement_memory</span><span class="p">,</span> <span class="n">corr_matrices_mem</span><span class="p">))</span> <span class="c1"># @UndefinedVariable</span>
            
            <span class="n">iterators</span> <span class="o">=</span> <span class="p">[]</span>            
            <span class="n">it_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">tau_max</span><span class="o">*</span><span class="n">num_blocks</span><span class="o">/</span><span class="n">n_proc</span><span class="p">))</span>
            <span class="n">printsteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">tau_max</span><span class="o">*</span><span class="n">num_blocks</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            
            <span class="n">curr_it</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">tau_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">printsteps</span><span class="p">:</span>                        
                        <span class="n">curr_it</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n_block</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">curr_it</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n_block</span><span class="p">,</span> <span class="n">tau</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_it</span><span class="p">)</span><span class="o">&gt;</span><span class="n">it_len</span><span class="p">:</span>
                        <span class="n">iterators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_it</span><span class="p">)</span>
                        <span class="n">curr_it</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iterators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_it</span><span class="p">)</span>
    
            
            <span class="k">for</span> <span class="n">curr_it</span> <span class="ow">in</span> <span class="n">iterators</span><span class="p">:</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_covariance</span> <span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">curr_it</span><span class="p">,</span>
                                                            <span class="n">tau_max</span><span class="p">,</span>
                                                            <span class="n">block_length</span><span class="p">,</span> 
                                                            <span class="n">ref_channels</span><span class="p">,</span> 
                                                            <span class="n">all_channels</span><span class="p">,</span> 
                                                            <span class="n">measurement_shape</span><span class="p">,</span>
                                                            <span class="n">corr_mats_shape</span><span class="p">))</span>
                                      
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>               
    
    
            <span class="n">corr_matrices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">corr_mats_mem</span> <span class="ow">in</span> <span class="n">corr_matrices_mem</span><span class="p">:</span>
                <span class="n">corr_mats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">corr_mats_mem</span><span class="o">.</span><span class="n">get_obj</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">corr_mats_shape</span><span class="p">)</span> 
                <span class="n">corr_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_mats</span><span class="o">*</span><span class="n">num_blocks</span><span class="p">)</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_matrices</span> <span class="o">=</span> <span class="n">corr_matrices</span>      
            
            <span class="n">corr_mats_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">corr_matrices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1">#corr_mats_mean = np.sum(corr_matrices, axis=0)</span>
            <span class="c1">#corr_mats_mean /= num_blocks - 1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">corr_mats_mean</span> <span class="o">=</span> <span class="n">corr_mats_mean</span>
            <span class="c1">#self.corr_mats_std = np.std(corr_matrices, axis=0)</span>
            
            <span class="n">subspace_matrix</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">block_column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">):</span>
                <span class="n">this_block_column</span> <span class="o">=</span> <span class="n">corr_mats_mean</span><span class="p">[</span><span class="n">block_column</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">:(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">block_column</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,:]</span>
                <span class="n">subspace_matrix</span><span class="p">[:,</span><span class="n">block_column</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">block_column</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">]</span><span class="o">=</span><span class="n">this_block_column</span>        
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span> <span class="o">=</span> <span class="n">subspace_matrix</span>
            
            <span class="n">subspace_matrices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
                <span class="n">corr_matrix</span> <span class="o">=</span> <span class="n">corr_matrices</span><span class="p">[</span><span class="n">n_block</span><span class="p">]</span>
                <span class="n">this_subspace_matrix</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">block_column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">):</span>
                    <span class="n">this_block_column</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="p">[</span><span class="n">block_column</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">:(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">block_column</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,:]</span>
                    <span class="n">this_subspace_matrix</span><span class="p">[:,</span><span class="n">block_column</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">block_column</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">]</span><span class="o">=</span><span class="n">this_block_column</span>
                <span class="n">subspace_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_subspace_matrix</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrices</span> <span class="o">=</span> <span class="n">subspace_matrices</span>
            
        <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
            
            <span class="n">q</span> <span class="o">=</span> <span class="n">num_block_rows</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">num_block_rows</span>
            <span class="n">block_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">total_time_steps</span> <span class="o">-</span> <span class="n">q</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">num_blocks</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">block_length</span> <span class="o">&lt;</span> <span class="n">num_ref_channels</span><span class="o">*</span><span class="n">q</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Block-length (=</span><span class="si">{}</span><span class="s1">) may not be smaller than the number of reference channels * number of block rows (=</span><span class="si">{}</span><span class="s1">)! </span><span class="se">\n</span><span class="s1"> Lower the number of blocks (=</span><span class="si">{}</span><span class="s1">), lower the number of reference channels (=</span><span class="si">{}</span><span class="s1">) or lower the number of block rows(=</span><span class="si">{}</span><span class="s1">)!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block_length</span><span class="p">,</span> <span class="n">num_ref_channels</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">,</span> <span class="n">num_ref_channels</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">block_length</span><span class="o">*</span><span class="n">num_blocks</span> <span class="c1"># might omit some timesteps in favor of equally sized blocks</span>
            
            <span class="n">Y_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">q</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
            <span class="n">Y_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                <span class="n">Y_minus</span><span class="p">[(</span><span class="n">q</span><span class="o">-</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">:(</span><span class="n">q</span><span class="o">-</span><span class="n">ii</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[(</span><span class="n">ii</span><span class="p">):(</span><span class="n">ii</span><span class="o">+</span><span class="n">N</span><span class="p">),</span><span class="n">ref_channels</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">Y_plus</span><span class="p">[</span><span class="n">ii</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">:(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[(</span><span class="n">q</span><span class="o">+</span><span class="n">ii</span><span class="p">):(</span><span class="n">q</span><span class="o">+</span><span class="n">ii</span><span class="o">+</span><span class="n">N</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
                
            <span class="n">Hankel_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Y_minus</span><span class="p">,</span><span class="n">Y_plus</span><span class="p">))</span>
            <span class="c1">#Hankel_matrix /=np.sqrt(N)</span>
<span class="c1">##################################</span>
            <span class="c1">#self.Hankel_matrix = Hankel_matrix/np.sqrt(N)</span>
            
            <span class="n">hankel_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">Hankel_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block_length</span><span class="p">,</span> <span class="n">block_length</span><span class="o">*</span><span class="n">num_blocks</span><span class="p">,</span> <span class="n">block_length</span><span class="p">))</span>
            <span class="c1">#print(Hankel_matrix.shape, block_length*num_blocks, total_time_steps)</span>
            <span class="k">for</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
                <span class="c1">#print(n_block, subspace_matrices[n_block].shape)</span>
                <span class="n">hankel_matrices</span><span class="p">[</span><span class="n">n_block</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">block_length</span><span class="p">)</span><span class="o">*</span><span class="n">num_blocks</span>
                <span class="c1">#hankel_matrices[n_block] /= np.sqrt(num_blocks)</span>
<span class="c1">##################################</span>
                
    <span class="c1">#         extract_length = int(np.floor(total_time_steps/num_blocks))</span>
    <span class="c1">#                    </span>
    <span class="c1"># </span>
    <span class="c1">#         </span>
    <span class="c1">#         </span>
    <span class="c1">#         hankel_matrices = []</span>
    <span class="c1">#         </span>
    <span class="c1">#         for n_block in range(num_blocks):</span>
    <span class="c1">#             # Extract reference time series </span>
    <span class="c1">#             this_measurement = measurement[n_block*extract_length:(n_block+1)*extract_length,:]</span>
    <span class="c1">#             N = extract_length - p - q - 1</span>
    <span class="c1">#             </span>
    <span class="c1">#             all_channels = ref_channels + roving_channels</span>
    <span class="c1">#             all_channels.sort()</span>
    <span class="c1">#             </span>
    <span class="c1">#             refs = this_measurement[:,ref_channels]</span>
    <span class="c1">#             </span>
    <span class="c1">#             #print(&#39;Creating block Hankel matrix...&#39;)</span>
    <span class="c1">#             </span>
    <span class="c1">#             Y_minus = np.zeros((q*num_ref_channels,N))</span>
    <span class="c1">#             Y_plus = np.zeros(((p+1)*num_analised_channels,N))</span>
    <span class="c1">#             </span>
    <span class="c1">#             </span>
    <span class="c1">#             for ii in range(q):</span>
    <span class="c1">#                 Y_minus[(q-ii-1)*num_ref_channels:(q-ii)*num_ref_channels,:] = refs[ii:(ii+N)].T</span>
    <span class="c1">#                 </span>
    <span class="c1">#             for ii in range(p+1):</span>
    <span class="c1">#                 Y_plus[ii*num_analised_channels:(ii+1)*num_analised_channels,:] = this_measurement[(q+ii):(q+ii+N)].T</span>
    <span class="c1">#                 </span>
    <span class="c1">#             Hankel_matrix = np.vstack((Y_minus,Y_plus))</span>
    <span class="c1">#             Hankel_matrix /= np.sqrt(N)</span>
    <span class="c1">#             subspace_matrices.append(Hankel_matrix)</span>
                
<span class="c1">#             self.hankel_matrices = hankel_matrices</span>
            
            <span class="n">H_dat_matrices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">R_11_matrices</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="n">printsteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_blocks</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            
            <span class="c1"># could eventually be parallelized</span>
            <span class="k">for</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>                   
                <span class="k">while</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="n">printsteps</span><span class="p">:</span> 
                    <span class="k">del</span> <span class="n">printsteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1">#num_block_columns*num_ref_channels + p*num_analised_channels, N</span>
                <span class="c1">#L,Q = lq_decomp(self.hankel_matrices[n_block], mode=&#39;reduced&#39;, unique=True)#eventually change mode to &#39;r&#39; and omit Q</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">lq_decomp</span><span class="p">(</span><span class="n">hankel_matrices</span><span class="p">[</span><span class="n">n_block</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># num_block_columns*num_ref_channels + p*num_analised_channels,K; K, N</span>
                
                <span class="n">R11</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span> <span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span><span class="p">]</span> 
                <span class="n">R_11_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R11</span><span class="p">)</span>
                
                <span class="n">R21</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span><span class="p">:</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span> <span class="o">+</span> <span class="n">num_analised_channels</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span><span class="p">]</span> 
                <span class="n">H_dat_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R21</span><span class="p">)</span>
            
            
            <span class="n">R_11_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">R_11_matrices</span><span class="p">)</span> <span class="c1">#num_ref_channels*num_block_columns,n_blocks*num_ref_channels*num_block_columns</span>
            <span class="n">L_breve</span><span class="p">,</span> <span class="n">Q_breve</span> <span class="o">=</span> <span class="n">lq_decomp</span><span class="p">(</span><span class="n">R_11_matrices</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reduced&#39;</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># num_ref_channels*num_block_columns,K;K,n_blocks*num_ref_channels*num_block_columns</span>
            
            <span class="n">Q_11_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span><span class="n">Q_breve</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span><span class="p">,</span><span class="n">num_blocks</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span><span class="p">,</span> <span class="n">num_ref_channels</span><span class="o">*</span><span class="n">num_block_columns</span><span class="p">))</span>

            <span class="n">printsteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_blocks</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>                     
                <span class="k">while</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="n">printsteps</span><span class="p">:</span> 
                    <span class="k">del</span> <span class="n">printsteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>          
                <span class="n">H_dat_matrix</span> <span class="o">=</span> <span class="n">H_dat_matrices</span><span class="p">[</span><span class="n">n_block</span><span class="p">]</span>
                <span class="n">Q_11_matrix</span> <span class="o">=</span> <span class="n">Q_11_matrices</span><span class="p">[</span><span class="n">n_block</span><span class="p">]</span>
                
                <span class="n">H_dat_matrices</span><span class="p">[</span><span class="n">n_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_dat_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q_11_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            
            <span class="c1">#M = np.mean(H_dat_matrices, axis = 0)            </span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">H_dat_matrices</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">)</span>
            
            <span class="c1">#L,Q = lq_decomp(self.Hankel_matrix, mode=&#39;reduced&#39;)#, unique=True)#eventually change mode to &#39;r&#39; and omit Q</span>
            <span class="c1">## q*num_ref_channels + p*num_analised_channels,K; K, N            </span>
            <span class="c1">#R21 = L[num_ref_channels*q:num_ref_channels*q + num_analised_channels*(p+1) , 0:num_ref_channels*q] </span>
            <span class="c1">#M = L[num_ref_channels*q:num_ref_channels*q + num_analised_channels*(p+1) , 0:num_ref_channels*q]   </span>
               
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrices</span> <span class="o">=</span> <span class="n">H_dat_matrices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">H_dat_matrices</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1">#self.M = M             </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>   </div>
      
<div class="viewcode-block" id="VarSSIRef.plot_covariances"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.plot_covariances">[docs]</a>    <span class="k">def</span> <span class="nf">plot_covariances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        <span class="n">num_block_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span>     
        <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>   
        
<span class="c1">#         subspace_matrices = []</span>
<span class="c1">#         for n_block in range(self.num_blocks):</span>
<span class="c1">#             corr_matrix = self.corr_matrices[n_block]</span>
<span class="c1">#             this_subspace_matrix= np.zeros(((num_block_rows+1)*num_analised_channels, num_block_columns*num_ref_channels))</span>
<span class="c1">#             for block_column in range(num_block_columns):</span>
<span class="c1">#                 this_block_column = corr_matrix[block_column*num_analised_channels:(num_block_rows+1+block_column)*num_analised_channels,:]</span>
<span class="c1">#                 this_subspace_matrix[:,block_column*num_ref_channels:(block_column+1)*num_ref_channels]=this_block_column</span>
<span class="c1">#             subspace_matrices.append(this_subspace_matrix)</span>
        <span class="c1">#self.subspace_matrices = subspace_matrices</span>
        <span class="n">subspace_matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrices</span>
        
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plot</span>
        <span class="c1">#matrices = subspace_matrices+[self.subspace_matrix]</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">subspace_matrix</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">num_channel</span><span class="p">,</span><span class="n">ref_channel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">ref_channels</span><span class="p">):</span>
                <span class="n">inds</span><span class="o">=</span><span class="p">([],[])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">):</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">ref_channel</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="o">+</span><span class="n">num_channel</span>
                    <span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                    <span class="n">inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num_block_rows</span><span class="p">):</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">ii</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="o">+</span><span class="n">ref_channel</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_block_columns</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="o">+</span><span class="n">num_channel</span>
                    <span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                    <span class="n">inds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">means</span> <span class="o">=</span> <span class="n">subspace_matrix</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
                <span class="c1">#print(means.shape, sigma_r[inds,inds].shape, len(inds))</span>
                <span class="c1">#plot.errorbar(range(num_block_rows+num_block_rows-1), means, yerr=np.sqrt(sigma_r[inds,inds]))</span>
                <span class="c1">#print(np.sqrt(sigma_r[inds,inds]))</span>
                     
                <span class="c1">#plot.plot(vec_R[inds,0])</span>
                <span class="c1">#plot.plot(vec_R[inds,1])</span>
                <span class="n">plot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num_block_columns</span><span class="o">+</span><span class="n">num_block_rows</span><span class="p">),</span> <span class="n">means</span><span class="p">)</span>
             
        <span class="n">plot</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
         
        
<div class="viewcode-block" id="VarSSIRef.init_child_process"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.init_child_process">[docs]</a>    <span class="k">def</span> <span class="nf">init_child_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measurement_memory_</span><span class="p">,</span> <span class="n">corr_matrices_mem_</span><span class="p">):</span>
        <span class="c1">#make the  memory arrays available to the child processes</span>
        
        <span class="k">global</span> <span class="n">measurement_memory</span>
        <span class="n">measurement_memory</span> <span class="o">=</span> <span class="n">measurement_memory_</span>   
        
        <span class="k">global</span> <span class="n">corr_matrices_mem</span>
        <span class="n">corr_matrices_mem</span> <span class="o">=</span> <span class="n">corr_matrices_mem_</span></div>
    
   
<div class="viewcode-block" id="VarSSIRef.compute_covariance"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.compute_covariance">[docs]</a>    <span class="k">def</span> <span class="nf">compute_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_it</span><span class="p">,</span> <span class="n">tau_max</span><span class="p">,</span> <span class="n">block_length</span><span class="p">,</span> <span class="n">ref_channels</span><span class="p">,</span> <span class="n">all_channels</span><span class="p">,</span> <span class="n">measurement_shape</span><span class="p">,</span> <span class="n">corr_mats_shape</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="n">overlap</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1">#sys.stdout.flush()</span>
        <span class="c1">#normalize=False</span>
        <span class="k">for</span> <span class="n">this_it</span> <span class="ow">in</span> <span class="n">curr_it</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_it</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">this_it</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">n_block</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">this_it</span>
            <span class="n">num_analised_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_channels</span><span class="p">)</span>
            
            <span class="n">measurement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">measurement_memory</span><span class="o">.</span><span class="n">get_obj</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">measurement_shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
                <span class="n">this_measurement</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[(</span><span class="n">n_block</span><span class="p">)</span><span class="o">*</span><span class="n">block_length</span><span class="p">:(</span><span class="n">n_block</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">block_length</span><span class="o">+</span><span class="n">tau</span><span class="p">,:]</span><span class="c1">#/np.sqrt(block_length)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">this_measurement</span> <span class="o">=</span> <span class="n">measurement</span><span class="p">[(</span><span class="n">n_block</span><span class="p">)</span><span class="o">*</span><span class="n">block_length</span><span class="p">:(</span><span class="n">n_block</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">block_length</span><span class="p">,:]</span>
                
            <span class="k">if</span> <span class="n">detrend</span><span class="p">:</span><span class="n">this_measurement</span> <span class="o">=</span> <span class="n">this_measurement</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">this_measurement</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="n">refs</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_measurement</span><span class="p">[:</span><span class="o">-</span><span class="n">tau</span><span class="p">,</span><span class="n">ref_channels</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            
            <span class="n">current_signals</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_measurement</span><span class="p">[</span><span class="n">tau</span><span class="p">:,</span> <span class="n">all_channels</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            
            <span class="n">this_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">current_signals</span><span class="p">,</span> <span class="n">refs</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">/</span><span class="n">current_signals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">corr_memory</span> <span class="o">=</span> <span class="n">corr_matrices_mem</span><span class="p">[</span><span class="n">n_block</span><span class="p">]</span>
            
            <span class="n">corr_mats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">corr_memory</span><span class="o">.</span><span class="n">get_obj</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">corr_mats_shape</span><span class="p">)</span>
            
            <span class="k">with</span> <span class="n">corr_memory</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
                <span class="n">corr_mats</span><span class="p">[(</span><span class="n">tau</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">:</span><span class="n">tau</span><span class="o">*</span><span class="n">num_analised_channels</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">this_block</span></div>
          
<div class="viewcode-block" id="VarSSIRef.compute_state_matrices"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.compute_state_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">compute_state_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_model_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lsq_method</span><span class="o">=</span><span class="s1">&#39;pinv&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        computes the state and output matrix of the state-space-model</span>
<span class="sd">        by applying a singular value decomposition to the block-hankel-matrix of covariances</span>
<span class="sd">        the state space model matrices are obtained by appropriate truncation </span>
<span class="sd">        of the svd matrices at max_model_order</span>
<span class="sd">        the decision whether to take merged covariances is taken automatically</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">lsq_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pinv&#39;</span><span class="p">,</span><span class="s1">&#39;qr&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        

        <span class="n">subspace_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="c1"># p</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing state matrices with </span><span class="si">{}</span><span class="s1">-based method...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lsq_method</span><span class="p">))</span>
        
        <span class="c1">#[U,S,V_T] = np.linalg.svd(subspace_matrix,1)</span>
        <span class="p">[</span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V_T</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">subspace_matrix</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#[U,S,V_T] = scipy.sparse.linalg.svds(subspace_matrix,k=max_model_order)</span>

        <span class="c1">#print(S.shape)</span>
        <span class="c1"># choose highest possible model order</span>
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_model_order</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_model_order</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>

        <span class="c1">#print(S.shape)</span>
        <span class="n">S_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">S</span><span class="p">)[:</span><span class="n">max_model_order</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="c1">#print(U.shape)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,:</span><span class="n">max_model_order</span><span class="p">]</span>
        <span class="c1">#print(U.shape)</span>
        <span class="n">V_T</span> <span class="o">=</span> <span class="n">V_T</span><span class="p">[:</span><span class="n">max_model_order</span><span class="p">,:]</span>
        <span class="c1">#import matplotlib.pyplot as plot</span>
        <span class="c1">#plot.plot(S_2)</span>
        
        <span class="n">O</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">S_2</span><span class="p">)</span>
        <span class="c1">#plot.matshow(O)</span>
        <span class="c1">#plot.show()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">O</span> <span class="o">=</span> <span class="n">O</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span> <span class="n">U</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span> <span class="o">=</span> <span class="n">V_T</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_channels</span><span class="p">,:]</span>   
        
        <span class="n">O_up</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">,:]</span>

        <span class="n">O_down</span> <span class="o">=</span> <span class="n">O</span><span class="p">[</span><span class="n">num_channels</span><span class="p">:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,:]</span>
        
        <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">O_up</span><span class="p">),</span> <span class="n">O_down</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
            <span class="n">Q_nmax</span><span class="p">,</span> <span class="n">R_nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">O_up</span><span class="p">)</span>
            <span class="n">S_nmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q_nmax</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">O_down</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Q_nmax</span> <span class="o">=</span> <span class="n">Q_nmax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R_nmax</span> <span class="o">=</span> <span class="n">R_nmax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S_nmax</span> <span class="o">=</span> <span class="n">S_nmax</span>
            <span class="n">A</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">R_nmax</span><span class="p">,</span> <span class="n">S_nmax</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span> <span class="o">=</span> <span class="n">C</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span><span class="o">=</span><span class="n">max_model_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">=</span> <span class="n">lsq_method</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>
        
<div class="viewcode-block" id="VarSSIRef.prepare_sensitivities"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.prepare_sensitivities">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_sensitivities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance_algo</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="k">assert</span> <span class="n">variance_algo</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span><span class="s1">&#39;slow&#39;</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Preparing sensitivities for use with </span><span class="si">{}</span><span class="s1"> (co)variance algorithm...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variance_algo</span><span class="p">))</span>
        
        <span class="n">num_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span> <span class="c1"># r</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span> <span class="c1">#r_o</span>
        <span class="n">num_block_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span> <span class="c1"># q</span>
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        
        <span class="n">num_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_blocks</span>
        <span class="n">subspace_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_method</span>
        
        <span class="n">lsq_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lsq_method</span>
        <span class="n">max_model_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
        <span class="n">subspace_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span>
        
        <span class="c1"># precomputation of T for fast algorithm</span>
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">or</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
            <span class="n">subspace_matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrices</span>        
            <span class="n">T</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_channels</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">,</span><span class="n">num_blocks</span><span class="p">))</span>

            <span class="c1">#T *= np.sqrt(int(np.floor((self.prep_data.total_time_steps-num_block_rows-num_block_columns)/num_blocks))*num_blocks)</span>
            <span class="k">if</span> <span class="mi">1</span><span class="p">:</span><span class="c1">#subspace_method == &#39;covariance&#39;:            </span>
                <span class="k">for</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
                    <span class="n">this_hankel</span> <span class="o">=</span> <span class="n">subspace_matrices</span><span class="p">[</span><span class="n">n_block</span><span class="p">]</span>
                    <span class="n">T</span><span class="p">[:,</span><span class="n">n_block</span><span class="p">:</span><span class="n">n_block</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">vectorize</span><span class="p">(</span><span class="n">this_hankel</span><span class="o">-</span><span class="n">subspace_matrix</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">num_blocks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">T</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_blocks</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">num_blocks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="c1"># sqrt because, SIGMA = np.dot(T,T) squares up the denominator</span>
<span class="c1">#             elif subspace_method == &#39;projection&#39;:</span>
<span class="c1">#                 M = self.M            </span>
<span class="c1">#                 for n_block in range(num_blocks):</span>
<span class="c1">#                     this_hankel = subspace_matrices[n_block]</span>
<span class="c1">#                     T[:,n_block:n_block+1]=vectorize(this_hankel-subspace_matrix)</span>
<span class="c1">#                 #T *= np.sqrt(int(np.floor((self.prep_data.total_time_steps-num_block_rows-num_block_columns)/num_blocks))*num_blocks)</span>
<span class="c1">#                 T /= np.sqrt(num_blocks-1)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hankel_cov_matrix</span> <span class="o">=</span> <span class="n">T</span>

        <span class="c1"># precomputation of Sigma_R and S3 for slow algorithm </span>
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
            <span class="n">corr_matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_matrices</span>
            <span class="n">corr_mats_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_mats_mean</span>
            
            <span class="n">sigma_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">num_block_columns</span><span class="o">+</span><span class="n">num_block_rows</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_channels</span> <span class="o">*</span> <span class="n">num_ref_channels</span><span class="p">,</span> <span class="p">(</span><span class="n">num_block_columns</span><span class="o">+</span><span class="n">num_block_rows</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_channels</span> <span class="o">*</span> <span class="n">num_ref_channels</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">n_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
                <span class="n">this_corr</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">corr_matrices</span><span class="p">[</span><span class="n">n_block</span><span class="p">])</span><span class="o">-</span><span class="n">vectorize</span><span class="p">(</span><span class="n">corr_mats_mean</span><span class="p">)</span>
                <span class="n">sigma_R</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">this_corr</span><span class="p">,</span><span class="n">this_corr</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">sigma_R</span> <span class="o">/=</span> <span class="p">(</span><span class="n">num_blocks</span><span class="o">*</span><span class="p">(</span><span class="n">num_blocks</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_R</span> <span class="o">=</span> <span class="n">sigma_R</span>
             
            <span class="n">S3</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_block_columns</span><span class="p">):</span>
                <span class="n">S3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_ref_channels</span><span class="p">),</span><span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">)),</span>
                                                                                       <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">),</span>
                                                                                       <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="p">(</span><span class="n">num_block_columns</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">))]))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">S3</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S3</span> <span class="o">=</span> <span class="n">S3</span>    
        
        <span class="k">elif</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
            <span class="n">sigma_H</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma_H</span> <span class="o">=</span> <span class="n">sigma_H</span>
        
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
        <span class="n">V_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span>
        
        <span class="n">O</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">O</span>
        <span class="n">O_up</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">,:]</span>
        <span class="n">O_down</span> <span class="o">=</span> <span class="n">O</span><span class="p">[</span><span class="n">num_channels</span><span class="p">:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,:]</span>
        <span class="c1"># Computation of Q_1 ... Q_4 in (36): For i = 1...n_b compute B_i,1 in (29) T_i,1 , T_i,2 (J_O,H T)_i in Remark 9 and the i-th block line of Q_1 ... Q_4 in (37)</span>
                <span class="c1"># S_1 in 3.1</span>
        <span class="n">S1</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">),</span> 
                                  <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span><span class="n">num_channels</span><span class="p">))])</span>
        
        <span class="n">S2</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span><span class="n">num_channels</span><span class="p">)),</span> 
                                  <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)])</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">S1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">O</span><span class="p">)</span><span class="o">==</span><span class="n">O_up</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">O</span><span class="p">)</span><span class="o">==</span><span class="n">O_down</span><span class="p">))</span>
            
        <span class="c1"># Precomputation of J_AO for qr based state matrix computation</span>
        <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
            <span class="c1">######</span>
            <span class="c1"># this whole method should be reformulated using less dot products</span>
            <span class="c1"># with selection matrices, but instead use slicing operations</span>
            <span class="c1">######</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;J_Rnmax&#39;</span><span class="p">)</span>
            <span class="n">R_nmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_nmax</span>
            <span class="n">Q_nmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_nmax</span>
            
            <span class="n">S_3</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">max_model_order</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_model_order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">S_3</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">max_model_order</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">max_model_order</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="c1">#S_3=S_3.toarray()</span>
            <span class="n">S_4</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">max_model_order</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_model_order</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">k1</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">S_4</span><span class="p">[(</span><span class="n">k1</span><span class="p">)</span><span class="o">*</span><span class="n">max_model_order</span><span class="o">+</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">k1</span><span class="p">)</span><span class="o">*</span><span class="n">max_model_order</span><span class="o">+</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="c1">#S_4 = S_4.toarray()</span>
            <span class="n">R_nmaxi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R_nmax</span><span class="p">)</span>
            
            <span class="n">P_nn</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">O</span><span class="p">)</span><span class="o">==</span><span class="n">O</span><span class="p">[</span><span class="n">num_channels</span><span class="p">:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,:]))</span>  
                <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">S1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">O</span><span class="p">)</span><span class="o">==</span><span class="n">O</span><span class="p">[:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="p">),:]))</span>
                <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">))</span>
                <span class="n">b</span><span class="o">=</span><span class="n">vectorize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">dia</span> <span class="o">=</span> <span class="n">S_3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">dia</span> <span class="o">=</span> <span class="n">dia</span><span class="p">[</span><span class="n">dia</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#print(dia)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="n">dia</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">S_4</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">),(</span><span class="n">max_model_order</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1">#first =  sparse.bsr_matrix(S_3 + S_4 + P_nn.T.dot(S_4.T).T)</span>
            <span class="c1">#print(0.1)</span>
            <span class="c1">#print(S1.shape, Q_nmax.T.shape, num_channels*num_block_rows,num_channels, Q_nmax.T.dot(S1.toarray()).shape)</span>
            <span class="c1">#second = sparse.kron(R_nmaxi.T,sparse.hstack([Q_nmax.T, sparse.bsr_matrix((max_model_order,num_channels))]))</span>
            <span class="c1">#print(0.2, type(first), type(second))</span>
            <span class="c1">#third = first.dot(second)</span>
            <span class="c1">#print(0.3)</span>
            <span class="n">U_</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">bsr_matrix</span><span class="p">(</span><span class="n">S_3</span> <span class="o">+</span> <span class="n">S_4</span> <span class="o">+</span> <span class="n">P_nn</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S_4</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">R_nmaxi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Q_nmax</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">bsr_matrix</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span><span class="n">num_channels</span><span class="p">))])))</span>
            <span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">J_Rnmax</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">R_nmax</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U_</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">P_rn</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">R_nmaxi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">S1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">),</span><span class="n">Q_nmax</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
            <span class="n">third</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U_</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
            <span class="n">fourth</span> <span class="o">=</span> <span class="n">first</span> <span class="o">-</span> <span class="n">third</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
            <span class="n">fifth</span> <span class="o">=</span> <span class="n">P_rn</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fourth</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
            <span class="n">sixth</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">O_down</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
            <span class="n">seventh</span> <span class="o">=</span> <span class="n">sixth</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fifth</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
            <span class="n">eighth</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q_nmax</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>
            <span class="n">nineth</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">),</span><span class="n">eighth</span><span class="p">)</span> 
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
            <span class="n">J_Snmax</span> <span class="o">=</span> <span class="n">seventh</span> <span class="o">+</span>  <span class="n">nineth</span>         
<span class="c1">#             J_Snmax = sparse.kron(O_down.T, sparse.identity(max_model_order)).dot(</span>
<span class="c1">#                              P_rn.dot(sparse.kron(R_nmaxi.T, S1)-</span>
<span class="c1">#                                       sparse.kron(sparse.identity(max_model_order),Q_nmax).dot(U_))</span>
<span class="c1">#                                       )\</span>
<span class="c1">#                         + sparse.kron(sparse.identity(max_model_order),S2.T.dot(Q_nmax).T)</span>
            <span class="c1">#print(4)    </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J_Rnmax</span> <span class="o">=</span> <span class="n">J_Rnmax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J_Snmax</span> <span class="o">=</span> <span class="n">J_Snmax</span>
        
        <span class="c1">#pre computation of I_OH at max model stratorder</span>
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
                <span class="n">BCS3</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">vuS3</span><span class="o">=</span><span class="p">[]</span>
                
            <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">BC</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">vu</span><span class="o">=</span><span class="p">[]</span>
                
            <span class="n">P_p1rqr0</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">)</span>
            
            <span class="n">S4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_model_order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">S4</span><span class="p">[(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">max_model_order</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span><span class="c1">#### ?????</span>
            
            <span class="n">printsteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>    
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">):</span>       
                <span class="k">while</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">printsteps</span><span class="p">:</span> 
                    <span class="k">del</span> <span class="n">printsteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">v_j_T</span> <span class="o">=</span>  <span class="n">V_T</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="n">u_j</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">s_j</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                
                <span class="n">B_j</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">s_j</span><span class="o">*</span><span class="n">subspace_matrix</span><span class="p">]),</span>
                              <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">s_j</span><span class="o">*</span><span class="n">subspace_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">)])])</span>
                
                <span class="n">C_j</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">s_j</span><span class="o">*</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">v_j_T</span><span class="p">,</span> <span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">))</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_j</span><span class="p">,</span><span class="n">u_j</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span>
                                     <span class="n">P_p1rqr0</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">u_j</span><span class="o">.</span><span class="n">T</span><span class="p">,(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_j_T</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">v_j_T</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
                    <span class="n">BCS3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C_j</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">B_j</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">vuS3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S3</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">v_j_T</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">u_j</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">BC</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C_j</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">B_j</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">vu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">v_j_T</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">u_j</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
                <span class="n">BCS3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">BCS3</span><span class="p">)</span>
                <span class="n">vuS3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">vuS3</span><span class="p">)</span>
                <span class="n">J_OHS3</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,:</span><span class="n">max_model_order</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)[:</span><span class="n">max_model_order</span><span class="p">],</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">))))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S4</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vuS3</span><span class="p">)</span><span class="o">+</span>
                        <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)[:</span><span class="n">max_model_order</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)),</span>
                                       <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">),</span>
                                                            <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">))]))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">BCS3</span><span class="p">)</span>
                               <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">J_OHS3</span> <span class="o">=</span> <span class="n">J_OHS3</span>
                
            <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">BC</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">BC</span><span class="p">)</span>
                <span class="n">vu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">vu</span><span class="p">)</span>
                     
                <span class="n">J_OH</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U</span><span class="p">[:,:</span><span class="n">max_model_order</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)[:</span><span class="n">max_model_order</span><span class="p">],</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">))))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S4</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vu</span><span class="p">)</span><span class="o">+</span>
                        <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)[:</span><span class="n">max_model_order</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)),</span>
                                       <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">),</span>
                                                      <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">))]))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">BC</span><span class="p">)</span>
                               <span class="p">)</span>  
                <span class="bp">self</span><span class="o">.</span><span class="n">J_OH</span> <span class="o">=</span> <span class="n">J_OH</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;J_OH&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">J_OH</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">J_OH</span><span class="p">[:</span><span class="n">max_model_order</span><span class="o">*</span><span class="n">num_block_rows</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,:]))</span> 
                
            

            
        <span class="c1"># Precomputation of J_OH*T for fast algorithm</span>
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>
            <span class="c1">#print(&#39;J_OHT&#39;)</span>
            <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>    
                <span class="n">Q1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">))</span>
                <span class="n">Q2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">))</span>
                <span class="n">Q3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">J_OHT</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">))</span> 
                   
            <span class="n">Q4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">J_OH</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">))</span>
    
            <span class="n">printsteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_model_order</span><span class="p">):</span>          
                <span class="k">while</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">printsteps</span><span class="p">:</span> 
                    <span class="k">del</span> <span class="n">printsteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
                <span class="n">beg</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">#beg,end=(i-1,i)</span>
                <span class="n">v_j_T</span> <span class="o">=</span>  <span class="n">V_T</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span><span class="n">end</span><span class="p">,:]</span>
                <span class="n">u_j</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="n">beg</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">s_j</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">beg</span><span class="p">]</span>
                <span class="c1">#print(S,s_i)</span>
                
                <span class="c1"># K_i, B_i,1; </span>
                <span class="n">K_j</span><span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">)</span><span class="o">+</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">)),</span>
                                 <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">v_j_T</span><span class="p">)])</span><span class="o">-</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">subspace_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">subspace_matrix</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">s_j</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    
                <span class="n">K_ji</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K_j</span><span class="p">)</span>
                <span class="n">HK_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">subspace_matrix</span><span class="p">,</span><span class="n">K_ji</span><span class="p">)</span><span class="o">/</span><span class="n">s_j</span>
                <span class="n">B_j1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">HK_j</span><span class="p">,</span><span class="n">subspace_matrix</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">s_j</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="o">-</span><span class="mi">1</span><span class="p">,(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">)),</span> 
                                                                           <span class="n">u_j</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
                                   <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">HK_j</span><span class="p">)])</span> 
             
                <span class="c1">#T_j,1; T_j,2</span>
                     
                <span class="n">T_j1</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">),</span><span class="n">u_j</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
                <span class="n">T_j2</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">v_j_T</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
                            
                <span class="c1"># (J_O,H T)_j</span>
                
                <span class="n">J_OHT_j</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">s_j</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_j</span><span class="p">,</span><span class="n">T_j1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_j_T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span>
                             <span class="n">s_j</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B_j1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">T_j2</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_j</span><span class="p">,</span><span class="n">T_j2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_j</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                                               <span class="n">T_j1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_j_T</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">T_j1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_j_T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)])))</span>
            
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> 
                    <span class="n">sol_hank_K_j</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">K_j</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">subspace_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                               
                    <span class="n">B_j1_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">)</span><span class="o">+</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sol_hank_K_j</span><span class="o">/</span><span class="n">s_j</span><span class="p">,</span>
                                         <span class="p">(</span><span class="n">subspace_matrix</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">s_j</span> <span class="o">-</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="o">-</span><span class="mi">1</span><span class="p">,(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">)),</span> 
                                                     <span class="n">u_j</span><span class="o">.</span><span class="n">T</span><span class="p">]))),</span>
                                      <span class="n">sol_hank_K_j</span><span class="o">/</span><span class="n">s_j</span><span class="p">])</span> 
                    
                    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">B_j1</span><span class="p">,</span> <span class="n">B_j1_o</span><span class="p">))</span>
                                       
                    <span class="n">C_j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">s_j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_j</span><span class="p">,</span><span class="n">u_j</span><span class="o">.</span><span class="n">T</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">v_j_T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">))),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_j_T</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">v_j_T</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_block_columns</span><span class="o">*</span><span class="n">num_ref_channels</span><span class="p">),</span><span class="n">u_j</span><span class="o">.</span><span class="n">T</span><span class="p">))])</span>
                     
                    <span class="n">J_OH</span><span class="p">[</span><span class="n">beg</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">:</span><span class="n">end</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,:]</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">s_j</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_j</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">v_j_T</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">u_j</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">s_j</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B_j1</span><span class="p">,</span><span class="n">C_j</span><span class="p">)</span>
                    
                <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>
                    <span class="n">Q1</span><span class="p">[</span><span class="n">beg</span><span class="o">*</span><span class="n">max_model_order</span><span class="p">:</span><span class="n">end</span><span class="o">*</span><span class="n">max_model_order</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">O_up</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_OHT_j</span><span class="p">[:</span><span class="n">num_channels</span><span class="o">*</span><span class="n">num_block_rows</span><span class="p">,:])</span> <span class="c1">#np.dot(np.dot(Oi_up.T,S1),J_OHTi)</span>
                    <span class="n">Q2</span><span class="p">[</span><span class="n">beg</span><span class="o">*</span><span class="n">max_model_order</span><span class="p">:</span><span class="n">end</span><span class="o">*</span><span class="n">max_model_order</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">O_down</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_OHT_j</span><span class="p">[:</span><span class="n">num_channels</span><span class="o">*</span><span class="n">num_block_rows</span><span class="p">,:])</span> <span class="c1">#np.dot(np.dot(Oi_down.T,S1),J_OHTi)</span>
                    <span class="n">Q3</span><span class="p">[</span><span class="n">beg</span><span class="o">*</span><span class="n">max_model_order</span><span class="p">:</span><span class="n">end</span><span class="o">*</span><span class="n">max_model_order</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">O_up</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_OHT_j</span><span class="p">[</span><span class="n">num_channels</span><span class="p">:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,:])</span> <span class="c1">#np.dot(np.dot(Oi_up.T,S2),J_OHTi)</span>
                    <span class="c1">#Q1[beg*max_model_order:end*max_model_order,:] = S1.T.dot(O_up).T.dot(J_OHT_j) #np.dot(np.dot(Oi_up.T,S1),J_OHTi)</span>
                    <span class="c1">#Q2[beg*max_model_order:end*max_model_order,:] = S1.T.dot(O_down).T.dot(J_OHT_j) #np.dot(np.dot(Oi_down.T,S1),J_OHTi)</span>
                    <span class="c1">#Q3[beg*max_model_order:end*max_model_order,:] = S2.T.dot(O_up).T.dot(J_OHT_j) #np.dot(np.dot(Oi_up.T,S2),J_OHTi)</span>
                
                <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">J_OHT</span><span class="p">[</span><span class="n">beg</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">:</span><span class="n">end</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,:]</span><span class="o">=</span><span class="n">J_OHT_j</span>
                    
                <span class="n">Q4</span><span class="p">[</span><span class="n">beg</span><span class="o">*</span><span class="n">num_channels</span><span class="p">:</span><span class="n">end</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">),</span>
                                                                               <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">num_channels</span><span class="p">,(</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">))]</span>
                                                                              <span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_OHT_j</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">J_OH</span> <span class="o">=</span> <span class="n">J_OH</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_OH</span><span class="p">,</span><span class="n">T</span><span class="p">),</span><span class="n">J_OHT</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">J_OHT</span> <span class="o">=</span> <span class="n">J_OHT</span>
                    
            <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>       
                <span class="bp">self</span><span class="o">.</span><span class="n">Q1</span> <span class="o">=</span> <span class="n">Q1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Q2</span> <span class="o">=</span> <span class="n">Q2</span>  
                <span class="bp">self</span><span class="o">.</span><span class="n">Q3</span> <span class="o">=</span> <span class="n">Q3</span>   
                
            <span class="bp">self</span><span class="o">.</span><span class="n">Q4</span> <span class="o">=</span> <span class="n">Q4</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">=</span> <span class="n">variance_algo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># previous modal params are invalid now</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  </div>
        
<div class="viewcode-block" id="VarSSIRef.compute_modal_params"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.compute_modal_params">[docs]</a>    <span class="k">def</span> <span class="nf">compute_modal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_model_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">qr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">max_model_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">max_model_order</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span><span class="o">=</span><span class="n">max_model_order</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing modal parameters with </span><span class="si">{}</span><span class="s1"> (co)variance computation...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span><span class="p">))</span>

        <span class="n">state_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span>
        <span class="n">output_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span>
               
        <span class="n">O</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">O</span>
        
        <span class="n">subspace_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_method</span>
        <span class="n">lsq_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lsq_method</span>
        <span class="n">variance_algo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span>
        <span class="n">max_model_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
        <span class="n">sampling_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">sampling_rate</span>
        
        <span class="n">num_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_analised_channels</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">num_ref_channels</span>
        <span class="n">num_block_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span>
        <span class="n">num_block_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
        
        <span class="n">accel_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">accel_channels</span>
        <span class="n">velo_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prep_data</span><span class="o">.</span><span class="n">velo_channels</span>
        
        <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
            <span class="n">R_nmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_nmax</span>
            <span class="n">S_nmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_nmax</span>
            <span class="n">J_Snmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_Snmax</span>
            <span class="n">J_Rnmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_Rnmax</span>
        
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
            <span class="n">J_OHS3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_OHS3</span>
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>  
            <span class="n">J_OH</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_OH</span>
            <span class="n">sigma_H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_H</span>
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span> 
            <span class="n">sigma_R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_R</span>
            
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>   
            <span class="n">Q4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q4</span> 
        <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">and</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
            <span class="n">J_OHT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J_OHT</span>                
        <span class="k">if</span>  <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">and</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>
            <span class="n">Q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q1</span>
            <span class="n">Q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q2</span>
            <span class="n">Q3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q3</span>  
        
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>
        <span class="n">std_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>        
        <span class="n">modal_damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>  
        <span class="n">std_damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">))</span>              
        <span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">std_mode_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">,</span> <span class="n">max_model_order</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># for future parallelization, may not even be necessary if numpy is using Intel MKL</span>
        <span class="c1"># params: order, max_model_order, num_channels, accel_channels, velo_channels, self.prep_data.channel_factors</span>
        <span class="c1"># read: state_matrix, output_matrix, Oi,  Q1,Q2,Q3,Q4, </span>
        <span class="c1"># functions: remove_conjugates(), integrate_quantities(), self.rescale_mode_shape()</span>
        <span class="c1"># write: modal_frequencies, std_frequencies, modal_damping, std_damping, mode_shapes, std_mode_shapes</span>
        
        <span class="n">S1</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">),</span> 
                                  <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span><span class="n">num_channels</span><span class="p">))])</span>
        
        <span class="n">S2</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(((</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span><span class="n">num_channels</span><span class="p">)),</span> 
                                  <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)])</span>
        
        <span class="n">printsteps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_model_order</span><span class="p">):</span>                    
            <span class="k">while</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">printsteps</span><span class="p">:</span> 
                <span class="k">del</span> <span class="n">printsteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>     

            <span class="n">On_up</span> <span class="o">=</span> <span class="n">O</span><span class="p">[:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="n">num_block_rows</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>               
                <span class="n">On_down</span> <span class="o">=</span> <span class="n">O</span><span class="p">[</span><span class="n">num_channels</span><span class="p">:</span><span class="n">num_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">,:</span><span class="n">order</span><span class="p">]</span>
                <span class="n">state_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up</span><span class="p">),</span> <span class="n">On_down</span><span class="p">)</span>  
            
            <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span> <span class="ow">and</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span><span class="p">:</span>              
                <span class="n">P_p1rn</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">((</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
                <span class="n">J_AO</span><span class="o">=</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">),</span><span class="n">S2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">-</span>
                      <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">state_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">S1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span>
                      <span class="n">P_p1rn</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">S1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">On_down</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">S1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">state_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                                     <span class="n">On_up</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                                                                              <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">On_up</span><span class="p">[:,:</span><span class="n">order</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">On_up</span><span class="p">[:,:</span><span class="n">order</span><span class="p">])))</span><span class="o">.</span><span class="n">T</span>
                      <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  
            <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>  
                <span class="c1">#R_n = self.R_nmax[:order,:order]</span>
                <span class="n">S_n</span> <span class="o">=</span> <span class="n">S_nmax</span><span class="p">[:</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">]</span>
                <span class="n">R_ni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R_nmax</span><span class="p">[:</span><span class="n">order</span><span class="p">,:</span><span class="n">order</span><span class="p">])</span>
                <span class="n">state_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R_ni</span><span class="p">,</span> <span class="n">S_n</span><span class="p">)</span>
                
                <span class="n">rows</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="n">max_model_order</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)])</span> 
                
                <span class="n">J_Rn</span> <span class="o">=</span> <span class="n">J_Rnmax</span><span class="p">[</span><span class="n">rows</span><span class="p">,:</span><span class="n">order</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">]</span>
                <span class="n">J_Sn</span> <span class="o">=</span> <span class="n">J_Snmax</span><span class="p">[</span><span class="n">rows</span><span class="p">,:</span><span class="n">order</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">]</span>
                <span class="n">J_AO</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">state_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">R_ni</span><span class="p">),</span><span class="n">J_Rn</span><span class="p">)</span><span class="o">+</span><span class="n">dot</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">),</span> <span class="n">R_ni</span><span class="p">),</span><span class="n">J_Sn</span><span class="p">)</span>
                
                <span class="c1">#T_n = sparse.vstack((sparse.identity(order, format=&#39;csr&#39;), sparse.csr_matrix((max_model_order-order,order))), format=&#39;csr&#39;)</span>
                <span class="c1">#J_AO = J_Snmax.T.dot(sparse.kron(T_n.T,T_n.dot(R_ni.T).T).T).T \</span>
                <span class="c1">#        -J_Rnmax.T.dot(sparse.kron(T_n.dot(state_matrix).T,T_n.dot(R_ni.T).T).T).T</span>
                <span class="c1">#print(np.all(J_AOe==J_AO[:order**2, :order*(num_block_rows+1)*num_channels]), J_AOe.shape, J_AO[:order**2, :order*(num_block_rows+1)*num_channels].shape)</span>
                <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span><span class="p">:</span>
                    <span class="n">J_AO</span> <span class="o">=</span> <span class="n">J_AO</span><span class="p">[:</span><span class="n">order</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">order</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>
                    <span class="c1">#J_AHT = J_AO.dot(J_OHT)</span>
                    <span class="n">J_AHT</span> <span class="o">=</span> <span class="n">J_AO</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_OHT</span><span class="p">[:</span><span class="n">order</span><span class="o">*</span><span class="p">(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">,:])</span>

            
            <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_l</span><span class="p">,</span> <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">state_matrix</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1">#eigvec_r = eigvec_r.T</span>
            <span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_l</span><span class="p">,</span> <span class="n">eigvec_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_conjugates_new</span><span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_l</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">)</span>      
                   
            <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span><span class="p">:</span>
                <span class="c1"># J_AO for pinv based</span>
                <span class="c1">#J_OHS3 = J_OHS3[:(num_block_rows+1)*num_channels*order,:]</span>
                
                <span class="n">J_CO</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">),</span><span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">),</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">num_channels</span><span class="p">,(</span><span class="n">num_block_rows</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="p">))]))</span>
                <span class="c1">#print(J_AO.shape, J_CO.shape, J_OHS3.shape)</span>
                <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
                    <span class="n">AS3</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">J_AO</span><span class="p">,</span><span class="n">J_CO</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_OHS3</span><span class="p">[:(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="o">*</span><span class="n">order</span><span class="p">,:])</span>
                    <span class="n">sigma_AC</span> <span class="o">=</span> <span class="n">AS3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sigma_R</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">AS3</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># with sigma_R</span>
                <span class="k">if</span> <span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
                    <span class="n">AS3</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">J_AO</span><span class="p">,</span><span class="n">J_CO</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_OH</span><span class="p">[:(</span><span class="n">num_block_rows</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_channels</span><span class="o">*</span><span class="n">order</span><span class="p">,:])</span>
                    <span class="n">sigma_AC</span> <span class="o">=</span> <span class="n">AS3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sigma_H</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">AS3</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    
            <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>
                <span class="n">Q4n</span> <span class="o">=</span> <span class="n">Q4</span><span class="p">[:</span><span class="n">num_channels</span><span class="o">*</span><span class="n">order</span><span class="p">,:]</span>
<span class="c1">#                 Q4n = sparse.hstack([sparse.identity(num_channels*order),</span>
<span class="c1">#                                            sparse.csr_matrix((num_channels*order,num_channels*(max_model_order-order)))]).dot(Q4)</span>
                
            <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">and</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>
                <span class="c1"># extraction of block rows from precomputed Q_i Matrices</span>
                
                <span class="n">rows</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="n">max_model_order</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)])</span>
                
<span class="c1">#                 S4n = sparse.kron(sparse.hstack([sparse.identity(order, format=&#39;csr&#39;),</span>
<span class="c1">#                                                              sparse.csr_matrix((order,max_model_order-order))]),</span>
<span class="c1">#                              sparse.hstack([sparse.identity(order, format=&#39;csr&#39;),</span>
<span class="c1">#                                                   sparse.csr_matrix((order,max_model_order-order))]))</span>
<span class="c1">#                 </span>
<span class="c1">#                 Q1n = S4n.dot(Q1)</span>
<span class="c1">#                 Q2n = S4n.dot(Q2)</span>
<span class="c1">#                 Q3n = S4n.dot(Q3)</span>
                
                <span class="n">Q1n</span> <span class="o">=</span> <span class="n">Q1</span><span class="p">[</span><span class="n">rows</span><span class="p">,:]</span>
                <span class="n">Q2n</span> <span class="o">=</span> <span class="n">Q2</span><span class="p">[</span><span class="n">rows</span><span class="p">,:]</span>
                <span class="n">Q3n</span> <span class="o">=</span> <span class="n">Q3</span><span class="p">[</span><span class="n">rows</span><span class="p">,:]</span>
                
<span class="c1">#                 print(np.all(Q1n==Q1n_))</span>
<span class="c1">#                 print(np.all(Q2n==Q2n_))</span>
<span class="c1">#                 print(np.all(Q3n==Q3n_))</span>
                
                <span class="c1">#Computation of (On_up On_up)^-1 , (P_nn + I_n2) Q1 and the sum P Q2 +Q3</span>
                <span class="n">On_up2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">On_up</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">On_up</span><span class="p">)</span>
                <span class="n">On_up2i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">On_up2</span><span class="p">)</span>
                
                <span class="n">P_nn</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="n">order</span><span class="p">)</span>
                
                <span class="n">PQ1</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_nn</span> <span class="o">+</span> <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q1n</span><span class="p">)</span>
                <span class="n">PQ23</span> <span class="o">=</span> <span class="n">P_nn</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q2n</span><span class="p">)</span> <span class="o">+</span> <span class="n">Q3n</span>
                
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">lambda_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eigval</span><span class="p">):</span>

                <span class="n">a_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">)))</span>
                <span class="n">b_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">))</span>
                <span class="n">freq_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sampling_rate</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">damping_i</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b_i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   
                
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>  
                    <span class="n">lambda_ci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">))</span><span class="o">*</span><span class="n">sampling_rate</span>
                    <span class="n">freq_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_ci</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                    <span class="n">damping_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambda_ci</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_ci</span><span class="p">)</span>
                
                <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">],</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
                <span class="n">mode_shape_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                
                <span class="c1"># integrate acceleration and velocity channels to level out all channels in phase and amplitude</span>
                <span class="c1">#mode_shape_i = self.integrate_quantities(mode_shape_i, accel_channels, velo_channels, complex(freq_i*2*np.pi))                </span>
                <span class="c1"># if each channel was preconditioned to a common vibration level reverse this in the mode shapes</span>
                <span class="c1">#mode_shape_i*=self.prep_data.channel_factors</span>
                <span class="c1"># scale mode shapes to unit modal displacement</span>
                <span class="c1">#mode_shape_i = self.rescale_mode_shape(mode_shape_i, doehler_style=True)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">))</span>
                <span class="n">s_ik</span> <span class="o">=</span> <span class="n">mode_shape_i</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">t_ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span>
                <span class="c1">#alpha = np.arctan(sik.imag/sik.real)</span>
                <span class="n">alpha_ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span>
                <span class="n">e_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_channels</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="c1">#, dtype=complex)</span>
                <span class="n">e_k</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">mode_shape_i</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">alpha_ik</span><span class="p">)</span>
                <span class="c1">#alpha = np.arctan(sik.imag/sik.real)</span>
                
                <span class="n">eigenvalues</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">lambda_i</span>
                <span class="n">modal_frequencies</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">freq_i</span>
                <span class="n">modal_damping</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">damping_i</span>
                <span class="n">mode_shapes</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">mode_shape_i</span>
                
                <span class="c1"># uncertainty computation</span>
                <span class="n">Phi_i</span> <span class="o">=</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Chi_i</span> <span class="o">=</span> <span class="n">eigvec_l</span><span class="p">[:,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1">#Compute J_fili , J_xili in Lemma 5</span>
                <span class="n">tlambda_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_i</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">a_i</span><span class="p">)</span><span class="o">*</span><span class="n">sampling_rate</span>
                <span class="n">J_fixiili</span><span class="o">=</span><span class="p">(</span><span class="n">sampling_rate</span><span class="o">/</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tlambda_i</span><span class="p">))</span><span class="o">*</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>  <span class="mi">0</span>                         <span class="p">],</span>
                                                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span>            <span class="mi">100</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tlambda_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)]]),</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">tlambda_i</span><span class="p">),</span>       <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">tlambda_i</span><span class="p">)],</span>
                                                   <span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">tlambda_i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>   <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">tlambda_i</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">tlambda_i</span><span class="p">)]])),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">),</span>   <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">)],</span>
                                            <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">),</span>  <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lambda_i</span><span class="p">)]]))</span>
                 <span class="p">)</span>
                <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>
                        <span class="c1">#Compute Q_i in (44)</span>
                        <span class="n">Q_i</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Phi_i</span><span class="o">.</span><span class="n">T</span> <span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">PQ23</span> <span class="o">-</span> <span class="n">lambda_i</span><span class="o">*</span><span class="n">PQ1</span><span class="p">)</span>
                        <span class="n">J_liHT</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">Phi_i</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">On_up2i</span><span class="p">,</span><span class="n">Q_i</span><span class="p">))</span>
                        
                    <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                        <span class="n">J_liA</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">Phi_i</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Phi_i</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
                        <span class="n">J_liHT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_liA</span><span class="p">,</span> <span class="n">J_AHT</span><span class="p">)</span>
                
                    <span class="c1"># Compute U_fixi in (42)</span>
                    <span class="n">U_fixi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_fixiili</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">J_liHT</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">J_liHT</span><span class="p">)]))</span>
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> 
                        <span class="c1"># avoid using the inverse of Oj_up2</span>
                        <span class="n">J_liHTs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">Phi_i</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">On_up2</span><span class="p">,</span><span class="n">Q_i</span><span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">J_liHT</span><span class="p">,</span> <span class="n">J_liHTs</span><span class="p">))</span>
                        <span class="n">J_liHT</span><span class="o">=</span><span class="n">J_liHTs</span>

                    <span class="c1"># Compute the covariance of fi and xi in (40)</span>
                    <span class="c1">#var_fixi=np.dot(U_fixi,U_fixi.T)</span>
                    <span class="n">var_fixi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">U_fixi</span><span class="p">,</span><span class="n">U_fixi</span><span class="p">)</span>
                    

                    <span class="c1">#Compute J_phi,A J_A,O J_O,HT in (46)</span>
                    <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>
                        <span class="n">J_PhiiHT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">lambda_i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="n">state_matrix</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Phi_i</span><span class="p">,</span> <span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">Phi_i</span><span class="p">),</span>
                                                 <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">On_up2i</span><span class="p">,</span>
                                                        <span class="n">Q_i</span><span class="p">)))</span>
                        
                    <span class="k">if</span> <span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                        <span class="n">J_PhiA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">lambda_i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="n">state_matrix</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Phi_i</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Phi_i</span><span class="p">,</span> <span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">Phi_i</span><span class="p">)))</span>
                        <span class="n">J_PhiiHT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_PhiA</span><span class="p">,</span><span class="n">J_AHT</span><span class="p">)</span>
                        
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="c1">#avoid using the inverse of Oj_up2</span>
                        <span class="n">J_PhiiHTs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">lambda_i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="n">state_matrix</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Phi_i</span><span class="p">,</span> <span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">Phi_i</span><span class="p">),</span>
                                                 <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">On_up2</span><span class="p">,</span>
                                                        <span class="n">Q_i</span><span class="p">)))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">J_PhiiHT</span><span class="p">,</span> <span class="n">J_PhiiHTs</span><span class="p">))</span>
                        <span class="n">J_PhiiHT</span> <span class="o">=</span> <span class="n">J_PhiiHTs</span>                      
                
                    <span class="c1">#Compute U_phi from (41) and (45) unit modal displacement scheme</span>
                    <span class="c1">#k = np.argmax(np.abs(mode_shape_i))</span>
<span class="c1">#                     J_mshiHT = (1/mode_shape_i[k]*</span>
<span class="c1">#                                 np.dot(np.identity(num_channels, dtype=complex)-np.hstack([np.zeros((num_channels,k),dtype=complex),</span>
<span class="c1">#                                                                                            np.reshape(mode_shape_i,(num_channels,1)),</span>
<span class="c1">#                                                                                            np.zeros((num_channels,num_channels-(k+1)),dtype=complex)]),</span>
<span class="c1">#                                        np.dot(output_matrix[:, 0:order],J_PhiiHT) + np.dot(np.kron(Phi_i.T,np.identity(num_channels)),</span>
<span class="c1">#                                                                                            Q4n)))</span>

                    <span class="n">J_phiiHT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">alpha_ik</span><span class="p">)</span><span class="o">*</span>\
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">t_ik</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="n">order</span><span class="p">],</span> <span class="n">Phi_i</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span><span class="o">*</span><span class="n">e_k</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span><span class="o">*</span><span class="n">e_k</span><span class="o">.</span><span class="n">T</span><span class="p">]))</span>
                                       <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">),</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)]),</span> 
                                       <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="n">order</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">J_PhiiHT</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Phi_i</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)),</span><span class="n">Q4n</span><span class="p">),</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="n">order</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">J_PhiiHT</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Phi_i</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)),</span><span class="n">Q4n</span><span class="p">)]))</span>
                    
                    
<span class="c1">#                     (1/mode_shape_i[k]*</span>
<span class="c1">#                                 np.dot(np.identity(num_channels, dtype=complex)-np.hstack([np.zeros((num_channels,k),dtype=complex),</span>
<span class="c1">#                                                                                            np.reshape(mode_shape_i,(num_channels,1)),</span>
<span class="c1">#                                                                                            np.zeros((num_channels,num_channels-(k+1)),dtype=complex)]),</span>
<span class="c1">#                                        np.dot(output_matrix[:, 0:order],J_PhiiHT) + np.dot(np.kron(Phi_i.T,np.identity(num_channels)),</span>
<span class="c1">#                                                                                            Q4n)))</span>
                
                    <span class="n">U_phii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">J_phiiHT</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">J_phiiHT</span><span class="p">)])</span>
                
                    <span class="c1">#Compute the covariance of phi in (40)</span>
                    <span class="c1">#var_phii=np.dot(U_phii,U_phii.T)</span>
                    <span class="c1">#print(U_phii.shape)</span>
                    <span class="c1">#print(&#39;1&#39;,var_phii)</span>
                    <span class="n">var_phii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">U_phii</span><span class="p">,</span><span class="n">U_phii</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span><span class="p">:</span>
                    
                    <span class="n">J_liA</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">Phi_i</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Phi_i</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
                    <span class="n">J_fixiA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J_fixiili</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">J_liA</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">J_liA</span><span class="p">)]))</span>
                    <span class="n">var_fixi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">J_fixiA</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">num_channels</span><span class="o">*</span><span class="n">order</span><span class="p">))]),</span><span class="n">sigma_AC</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">J_fixiA</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">num_channels</span><span class="o">*</span><span class="n">order</span><span class="p">))])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                    <span class="n">var_fixi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">var_fixi</span><span class="p">)</span>
                    
                    <span class="n">J_PhiA</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">lambda_i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="n">state_matrix</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Phi_i</span><span class="o">.</span><span class="n">T</span><span class="p">,(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Phi_i</span><span class="p">,</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Chi_i</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">Phi_i</span><span class="p">))))</span>
                 
                    <span class="n">J_phiiAC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">alpha_ik</span><span class="p">)</span><span class="o">*</span>\
                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">t_ik</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">],</span> <span class="n">Phi_i</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span><span class="o">*</span><span class="n">e_k</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">s_ik</span><span class="p">)</span><span class="o">*</span><span class="n">e_k</span><span class="o">.</span><span class="n">T</span><span class="p">]))</span>
                                       <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">),</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)]),</span> 
                                       <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">J_PhiA</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Phi_i</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">))]),</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">J_PhiA</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Phi_i</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num_channels</span><span class="p">))])]))</span>
                     
                    <span class="n">var_phii</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">J_phiiAC</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">J_phiiAC</span><span class="p">)]),</span><span class="n">sigma_AC</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">J_phiiAC</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">J_phiiAC</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                    <span class="n">var_phii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">var_phii</span><span class="p">)</span>
                                 
                
                <span class="n">std_frequencies</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_fixi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">std_damping</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_fixi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                
                <span class="n">std_mode_shapes</span><span class="o">.</span><span class="n">real</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_phii</span><span class="p">[:</span><span class="n">num_channels</span><span class="p">])</span>
                <span class="n">std_mode_shapes</span><span class="o">.</span><span class="n">imag</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">order</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_phii</span><span class="p">[</span><span class="n">num_channels</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">num_channels</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Frequency: </span><span class="si">{}</span><span class="s1">, Std_Frequency: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">freq_i</span><span class="p">,</span> <span class="n">std_frequencies</span><span class="p">[</span><span class="n">order</span><span class="p">,</span><span class="n">i</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Damping: </span><span class="si">{}</span><span class="s1">, Std_damping: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">damping_i</span><span class="p">,</span> <span class="n">std_damping</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mode_Shape: </span><span class="si">{}</span><span class="s1">, Std_Mode_Shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode_shape_i</span><span class="p">,</span> <span class="n">std_mode_shapes</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">order</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">eigenvalues</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">modal_frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_frequencies</span> <span class="o">=</span> <span class="n">std_frequencies</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="n">modal_damping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_damping</span> <span class="o">=</span> <span class="n">std_damping</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">mode_shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_mode_shapes</span> <span class="o">=</span> <span class="n">std_mode_shapes</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  </div>
        
<span class="c1">#     def compute_modal_params(self, max_model_order=None, debug=False): </span>
<span class="c1">#         </span>
<span class="c1">#         if max_model_order is not None:</span>
<span class="c1">#             assert max_model_order&lt;=self.max_model_order</span>
<span class="c1">#             self.max_model_order=max_model_order</span>
<span class="c1">#         </span>
<span class="c1">#         assert self.state[1]</span>
<span class="c1">#         </span>
<span class="c1">#         print(&#39;Computing modal parameters...&#39;)</span>
<span class="c1">#         state_matrix = self.state_matrix</span>
<span class="c1">#         output_matrix = self.output_matrix</span>
<span class="c1">#         subspace_matrix = self.subspace_matrix</span>
<span class="c1">#         O = self.O </span>
<span class="c1"># </span>
<span class="c1">#         lsq_method = self.lsq_method</span>
<span class="c1">#         max_model_order = self.max_model_order</span>
<span class="c1">#         sampling_rate = self.prep_data.sampling_rate</span>
<span class="c1">#         num_channels = self.prep_data.num_analised_channels</span>
<span class="c1">#         num_ref_channels = self.prep_data.num_ref_channels</span>
<span class="c1">#         num_block_columns = self.num_block_columns</span>
<span class="c1">#         num_block_rows = self.num_block_rows</span>
<span class="c1">#         </span>
<span class="c1">#         accel_channels=self.prep_data.accel_channels</span>
<span class="c1">#         velo_channels=self.prep_data.velo_channels</span>
<span class="c1"># </span>
<span class="c1">#         modal_frequencies = np.zeros((max_model_order, max_model_order))</span>
<span class="c1">#         std_frequencies = np.zeros((max_model_order, max_model_order))</span>
<span class="c1">#         modal_damping = np.zeros((max_model_order, max_model_order))  </span>
<span class="c1">#         std_damping = np.zeros((max_model_order, max_model_order))</span>
<span class="c1">#         mode_shapes = np.zeros((num_channels, max_model_order, max_model_order),dtype=complex)</span>
<span class="c1">#         std_mode_shapes = np.zeros((num_channels, max_model_order, max_model_order),dtype=complex)</span>
<span class="c1">#         </span>
<span class="c1">#         S3 = self.S3        </span>
<span class="c1">#         S1 = sparse.hstack([sparse.identity((num_block_rows)*num_channels), </span>
<span class="c1">#                                   sparse.csr_matrix(((num_block_rows)*num_channels,num_channels))])</span>
<span class="c1">#         </span>
<span class="c1">#         S2 = sparse.hstack([ sparse.csr_matrix(((num_block_rows)*num_channels,num_channels)), </span>
<span class="c1">#                                   sparse.identity((num_block_rows)*num_channels)])</span>
<span class="c1">#         </span>
<span class="c1">#         for order in range(1,max_model_order):</span>
<span class="c1">#             print(&#39;(c) Step up order: &#39;,order)        </span>
<span class="c1">#                       </span>
<span class="c1">#             On_up = O[:num_channels * (num_block_rows),:order]</span>
<span class="c1">#             On_down = O[num_channels:num_channels * (num_block_rows+1) ,:order]</span>
<span class="c1">#             if lsq_method == &#39;pinv&#39;:</span>
<span class="c1">#                 state_matrix = np.dot(np.linalg.pinv(On_up), On_down)</span>
<span class="c1">#                 </span>
<span class="c1">#                 P_p1rn = permutation((num_block_rows+1)*num_channels, order)</span>
<span class="c1">#                 J_AO=(sparse.kron(sparse.identity(order),S2.T.dot(np.linalg.pinv(On_up).T).T)-</span>
<span class="c1">#                       sparse.kron(state_matrix.T,S1.T.dot(np.linalg.pinv(On_up).T).T)+</span>
<span class="c1">#                       P_p1rn.T.dot(np.kron(S1.T.dot(On_down).T - S1.T.dot(np.dot(state_matrix.T,</span>
<span class="c1">#                                                                                      On_up.T).T</span>
<span class="c1">#                                                                               ).T,</span>
<span class="c1">#                                       np.linalg.inv(np.dot(On_up[:,:order].T,On_up[:,:order]))).T</span>
<span class="c1">#                       ).T)    </span>
<span class="c1">#             if lsq_method == &#39;qr&#39;:</span>
<span class="c1">#                 R_n = self.R_nmax[:order,:order]</span>
<span class="c1">#                 R_ni = np.linalg.inv(R_n)</span>
<span class="c1">#                 S_n = self.S_nmax[:order,:order]</span>
<span class="c1">#                 state_matrix = np.dot(R_ni, S_n)</span>
<span class="c1">#      </span>
<span class="c1">#                 T_n = np.vstack((np.identity(order), np.zeros((max_model_order-order,order))))</span>
<span class="c1">#                 J_AO = np.dot(np.kron(T_n.T,np.dot(R_ni, T_n.T)),self.J_Snmax) \</span>
<span class="c1">#                         -np.dot(np.kron(np.dot(state_matrix.T, T_n.T),np.dot(R_ni, T_n.T)), self.J_Rnmax)</span>
<span class="c1">#                 J_AO = J_AO[:order**2, :order*(num_block_rows+1)*num_channels]</span>
<span class="c1">#                 #J_AOHT = np.dot(J_AO, self.J_OHT)</span>
<span class="c1">#                 </span>
<span class="c1">#             eigval, eigvec_l, eigvec_r = scipy.linalg.eig(a=state_matrix,b=None,left=True,right=True)</span>
<span class="c1">#             eigval, eigvec_l, eigvec_r = self.remove_conjugates_new(eigval, eigvec_l, eigvec_r) </span>
<span class="c1"># </span>
<span class="c1">#             # K_i, B_i,1; </span>
<span class="c1">#             </span>
<span class="c1">#             </span>
<span class="c1">#             if debug: </span>
<span class="c1">#                 A=sparse.vstack([J_AO,J_CO]).dot(J_OH)</span>
<span class="c1">#                 sigma_ACT = A.dot(np.dot(self.hankel_cov_matrix,self.hankel_cov_matrix.T)).dot(A.T)# with sigma_H from T</span>
<span class="c1">#                 print(&#39;Sigma_AC (R,T)&#39;,np.allclose(sigma_AC, sigma_ACT))</span>
<span class="c1">#                 </span>
<span class="c1">#                 S4n = sparse.kron(sparse.hstack([sparse.identity(order),np.zeros((order,max_model_order-order))]),</span>
<span class="c1">#                              sparse.hstack([sparse.identity(order),np.zeros((order,max_model_order-order))]))</span>
<span class="c1">#                 </span>
<span class="c1">#                 Q1n = S4n.dot(self.Q1)</span>
<span class="c1">#                 Q2n = S4n.dot(self.Q2)</span>
<span class="c1">#                 Q3n = S4n.dot(self.Q3)</span>
<span class="c1">#                 Q4n = sparse.hstack([sparse.identity(num_channels*order),sparse.csr_matrix((num_channels*order,num_channels*(max_model_order-order)))]).dot(self.Q4)</span>
<span class="c1">#                 </span>
<span class="c1">#                 #Computation of (Oj_up Oj_up)^-1 , (P_nn + I_n2) Q1 and the sum P Q2 +Q3</span>
<span class="c1">#     </span>
<span class="c1">#                 On_up2 = np.dot(On_up.T, On_up)</span>
<span class="c1">#                 On_up2i = np.linalg.inv(On_up2)</span>
<span class="c1">#     </span>
<span class="c1">#                 P_nn = permutation(order,order)            </span>
<span class="c1">#                 </span>
<span class="c1">#                 PQ1 = (P_nn + sparse.identity(order**2)).dot(Q1n)</span>
<span class="c1">#                 PQ23 = P_nn.dot(Q2n) + Q3n</span>
<span class="c1">#                 </span>
<span class="c1">#                 J_AHT= np.dot(np.kron(np.identity(order),np.linalg.inv(On_up2)),np.dot(-1*np.kron(self.state_matrix.T,np.identity(order)),PQ1)+PQ23)</span>
<span class="c1">#                 J_AHTQ=J_AO.dot(np.dot(self.J_OH[:order*(num_block_rows+1)*num_channels,:],self.hankel_cov_matrix))</span>
<span class="c1">#                 print(&#39;J_AOHT&#39;,np.allclose(J_AHT, J_AHTQ))</span>
<span class="c1">#                 </span>
<span class="c1">#                 J_CHT = np.dot(np.dot(self.J_OH[:order*(num_block_rows+1)*num_channels,:],self.hankel_cov_matrix))</span>
<span class="c1">#                 J_CHTQ=Q4n</span>
<span class="c1">#                 print(&#39;J_COHT&#39;,np.allclose(J_CHTQ, J_CHT))</span>
<span class="c1">#                 </span>
<span class="c1">#                 U_AC = np.vstack([J_AHT,J_CHT])</span>
<span class="c1">#                 sigma_ACQ=np.dot(U_AC,U_AC.T)</span>
<span class="c1">#                 </span>
<span class="c1">#                 print(&#39;Sigma_AC (R,Q)&#39;, np.allclose(sigma_AC, sigma_ACQ))</span>
<span class="c1">#             </span>
<span class="c1"># </span>
<span class="c1">#             for i,lambda_i in enumerate(eigval):</span>
<span class="c1"># </span>
<span class="c1">#                 a_i = np.abs(np.arctan2(np.imag(lambda_i),np.real(lambda_i)))</span>
<span class="c1">#                 b_i = np.log(np.abs(lambda_i))</span>
<span class="c1">#                 freq_i = np.sqrt(a_i**2+b_i**2)*sampling_rate/2/np.pi</span>
<span class="c1">#                 damping_i = 100*np.abs(b_i)/np.sqrt(a_i**2+b_i**2)    </span>
<span class="c1">#                 </span>
<span class="c1">#                 if debug: </span>
<span class="c1">#                     lambda_ci=np.log(complex(lambda_i))*sampling_rate</span>
<span class="c1">#                     freq_i=np.abs(lambda_ci)/2/np.pi</span>
<span class="c1">#                     damping_i=-100*np.real(lambda_ci)/np.abs(lambda_ci)</span>
<span class="c1">#                 </span>
<span class="c1">#                 mode_shape_i = np.dot(output_matrix[:, 0:order], eigvec_r[:,i])</span>
<span class="c1">#                 mode_shape_i = np.array(mode_shape_i, dtype=complex)</span>
<span class="c1"># </span>
<span class="c1">#                 # integrate acceleration and velocity channels to level out all channels in phase and amplitude</span>
<span class="c1">#                 #mode_shape_i = self.integrate_quantities(mode_shape_i, accel_channels, velo_channels, complex(freq_i*2*np.pi))                </span>
<span class="c1">#                 # if each channel was preconditioned to a common vibration level reverse this in the mode shapes</span>
<span class="c1">#                 #mode_shape_i*=self.prep_data.channel_factors</span>
<span class="c1">#                 # scale mode shapes to unit modal displacement</span>
<span class="c1">#                 #mode_shape_i = self.rescale_mode_shape(mode_shape_i)</span>
<span class="c1">#                 </span>
<span class="c1">#                 k = np.argmax(np.abs(mode_shape_i))</span>
<span class="c1">#                 s_ik = mode_shape_i[k]</span>
<span class="c1">#                 t_ik = np.abs(s_ik)</span>
<span class="c1">#                 #alpha = np.arctan(sik.imag/sik.real)</span>
<span class="c1">#                 alpha_ik = np.angle(s_ik)</span>
<span class="c1">#                 mode_shape_i *= np.exp(-1j*alpha_ik)</span>
<span class="c1">#                 </span>
<span class="c1">#                 modal_frequencies[order,i] = freq_i</span>
<span class="c1">#                 modal_damping[order,i] = damping_i</span>
<span class="c1">#                 mode_shapes[:,i,order] = mode_shape_i</span>
<span class="c1">#                 </span>
<span class="c1">#                 # Uncertainty Computation</span>
<span class="c1">#                 Phi_i = eigvec_r[:,i:i+1]</span>
<span class="c1">#                 Chi_i = eigvec_l[:,i:i+1]</span>
<span class="c1">#                 </span>
<span class="c1">#                 J_liA = 1/np.dot(Chi_i.T.conj(),Phi_i)*np.kron(Phi_i.T,Chi_i.T.conj())</span>
<span class="c1">#                 J_PhiA= np.dot(np.linalg.pinv(lambda_i*np.identity(order)-state_matrix),</span>
<span class="c1">#                                np.kron(Phi_i.T,(np.identity(order)-np.dot(Phi_i,Chi_i.T.conj())/np.dot(Chi_i.T.conj(),Phi_i))))</span>
<span class="c1">#                 </span>
<span class="c1">#                 #Compute J_fili , J_xili in Lemma 5</span>
<span class="c1">#                 tlambda_i = (b_i+1j*a_i)*sampling_rate</span>
<span class="c1">#                 </span>
<span class="c1">#                 J_fixiili=(sampling_rate/((np.abs(lambda_i)**2) * np.abs(tlambda_i))*</span>
<span class="c1">#                  np.dot(np.dot(np.array([[1/2/np.pi,    0                         ],</span>
<span class="c1">#                                          [0,            100/(np.abs(tlambda_i)**2)]]),</span>
<span class="c1">#                                np.array([[np.real(tlambda_i),       np.imag(tlambda_i)],</span>
<span class="c1">#                                          [-(np.imag(tlambda_i)**2),   np.real(tlambda_i)*np.imag(tlambda_i)]])),</span>
<span class="c1">#                         np.array([[np.real(lambda_i),   np.imag(lambda_i)],</span>
<span class="c1">#                                   [-np.imag(lambda_i),  np.real(lambda_i)]]))</span>
<span class="c1">#                  )</span>
<span class="c1">#                 </span>
<span class="c1">#                 J_fixiA = np.dot(J_fixiili,np.vstack([np.real(J_liA),np.imag(J_liA)]))</span>
<span class="c1">#                 var_fixi = np.dot(np.hstack([J_fixiA, np.zeros((2,num_channels*order))]),sigma_AC.dot(np.hstack([J_fixiA, np.zeros((2,num_channels*order))]).T))</span>
<span class="c1">#                 </span>
<span class="c1">#                 #k = np.argmax(np.abs(mode_shape_i))</span>
<span class="c1"># #                 J_phiiAC = (1/mode_shape_i[k]*</span>
<span class="c1"># #                             np.dot(np.identity(num_channels, dtype=complex)-np.hstack([np.zeros((num_channels,k),dtype=complex),</span>
<span class="c1"># #                                                                                        np.reshape(mode_shape_i,(num_channels,1)),</span>
<span class="c1"># #                                                                                        np.zeros((num_channels,num_channels-(k+1)),dtype=complex)]),</span>
<span class="c1"># #                                    np.hstack([np.dot(output_matrix[:, 0:order],J_PhiA),np.kron(Phi_i.T,</span>
<span class="c1"># #                                                                                                np.identity(num_channels))])))</span>
<span class="c1">#                 e_k = np.zeros((num_channels,1))#, dtype=complex)</span>
<span class="c1">#                 e_k[k,0]=1</span>
<span class="c1">#                 J_phiiAC = np.exp(-1j*alpha_ik)*\</span>
<span class="c1">#                             np.dot(-1j*np.power(t_ik,-2)*np.dot(np.dot(output_matrix[:, 0:order], Phi_i),np.hstack([-np.imag(s_ik)*e_k.T,np.real(s_ik)*e_k.T]))</span>
<span class="c1">#                                    +np.hstack([np.identity(num_channels), 1j*np.identity(num_channels)]), </span>
<span class="c1">#                                    np.vstack([np.hstack([np.dot(output_matrix[:, 0:order],np.real(J_PhiA)), np.kron(np.real(Phi_i).T,np.identity(num_channels))]),</span>
<span class="c1">#                                               np.hstack([np.dot(output_matrix[:, 0:order],np.imag(J_PhiA)), np.kron(np.imag(Phi_i).T,np.identity(num_channels))])]))</span>
<span class="c1">#                 </span>
<span class="c1">#                 var_phii= np.dot(np.vstack([np.real(J_phiiAC),np.imag(J_phiiAC)]),sigma_AC.dot(np.vstack([np.real(J_phiiAC),np.imag(J_phiiAC)]).T))</span>
<span class="c1">#                 </span>
<span class="c1">#                 std_frequencies[order,i]=np.sqrt(var_fixi[0,0])</span>
<span class="c1">#                 std_damping[order, i]=np.sqrt(var_fixi[1,1])</span>
<span class="c1">#                 </span>
<span class="c1">#                 std_mode_shapes.real[:,i,order]=np.sqrt(var_phii[range(num_channels),range(num_channels)])</span>
<span class="c1">#                 std_mode_shapes.imag[:,i,order]=np.sqrt(var_phii[range(num_channels,2*num_channels),range(num_channels,2*num_channels)])</span>
<span class="c1">#                 </span>
<span class="c1">#                 if debug:</span>
<span class="c1">#                     print(&#39;Frequency: {}, Std_Frequency: {}&#39;.format(freq_i, std_frequencies[order,i]))</span>
<span class="c1">#                     print(&#39;Damping: {}, Std_damping: {}&#39;.format(damping_i, std_damping[order, i]))</span>
<span class="c1">#                     print(&#39;Mode_Shape: {}, Std_Mode_Shape: {}&#39;.format(mode_shape_i, std_mode_shapes[:,i,order]))</span>
<span class="c1">#                     </span>
<span class="c1">#         self.modal_frequencies = modal_frequencies</span>
<span class="c1">#         self.std_frequencies = std_frequencies</span>
<span class="c1">#         </span>
<span class="c1">#         self.modal_damping = modal_damping</span>
<span class="c1">#         self.std_damping = std_damping</span>
<span class="c1">#         </span>
<span class="c1">#         self.mode_shapes = mode_shapes</span>
<span class="c1">#         self.std_mode_shapes = std_mode_shapes</span>
<span class="c1">#         </span>
<span class="c1">#         self.state[2]=True</span>
<span class="c1">#         </span>
<span class="c1">#         #return sigma_AC, eigval, eigvec_l, eigvec_r</span>
<span class="c1">#         </span>
                    
<div class="viewcode-block" id="VarSSIRef.remove_conjugates_new"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.remove_conjugates_new">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">remove_conjugates_new</span> <span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="n">eigvec_l</span><span class="p">,</span> <span class="n">eigvec_r</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        removes conjugates</span>
<span class="sd">        </span>
<span class="sd">        eigvec_l.shape = [order+1, order+1]</span>
<span class="sd">        eigval.shape = [order+1,1]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#return vectors, eigval</span>
        <span class="n">num_val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">eigval</span><span class="p">)</span>
        <span class="n">conj_indices</span><span class="o">=</span><span class="n">deque</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_val</span><span class="p">):</span>
            <span class="n">this_val</span><span class="o">=</span><span class="n">eigval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">this_conj_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">this_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this_val</span> <span class="o">==</span> <span class="n">this_conj_val</span><span class="p">:</span> <span class="c1">#remove real eigvals</span>
                <span class="n">conj_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1">#ind=np.argmax(eigval[i+1:]==this_conj_val)</span>
            <span class="c1">#if ind: conj_indices.append(ind+i+1)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_val</span><span class="p">):</span> <span class="c1">#catches unordered conjugates but takes slightly longer</span>
                <span class="k">if</span> <span class="n">eigval</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_conj_val</span><span class="p">:</span>
        
                    <span class="c1">#if not np.allclose(eigvec_l[j],eigvec_l[i].conj()):</span>
                    <span class="c1">#    print(&#39;eigval is complex conjugate but eigvec_l is not&#39;)</span>
                    <span class="c1">#    continue</span>
        
                    <span class="c1">#if not np.allclose(eigvec_r[j],eigvec_r[i].conj()):</span>
                    <span class="c1">#    print(&#39;eigval is complex conjugate but eigvec_r is not&#39;)</span>
                    <span class="c1">#    continue</span>
                    
                    <span class="n">conj_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">break</span>
                
        <span class="c1">#print(&#39;indices of complex conjugate: {}&#39;.format(conj_indices))</span>
        <span class="n">conj_indices</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_val</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">conj_indices</span><span class="p">))</span>
        <span class="c1">#print(&#39;indices to keep and return: {}&#39;.format(conj_indices))</span>
        
        
        <span class="n">eigvec_l</span> <span class="o">=</span> <span class="n">eigvec_l</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
        <span class="n">eigvec_r</span> <span class="o">=</span> <span class="n">eigvec_r</span><span class="p">[:,</span><span class="n">conj_indices</span><span class="p">]</span>
        <span class="n">eigval</span> <span class="o">=</span> <span class="n">eigval</span><span class="p">[</span><span class="n">conj_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">eigval</span><span class="p">,</span><span class="n">eigvec_l</span><span class="p">,</span><span class="n">eigvec_r</span></div>
    
<div class="viewcode-block" id="VarSSIRef.integrate_quantities"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.integrate_quantities">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">integrate_quantities</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">accel_channels</span><span class="p">,</span> <span class="n">velo_channels</span><span class="p">,</span> <span class="n">omega</span><span class="p">):</span>
        <span class="c1"># input quantities = [a, v, d]</span>
        <span class="c1"># output quantities = [d, d, d]</span>
        <span class="c1"># converts amplitude and phase</span>
        <span class="c1">#                     phase + 180; magn / omega^2</span>
        
        <span class="n">vector</span><span class="p">[</span><span class="n">accel_channels</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>       <span class="o">/</span> <span class="p">(</span><span class="n">omega</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1">#                    phase + 90; magn / omega</span>
        <span class="n">vector</span><span class="p">[</span><span class="n">velo_channels</span><span class="p">]</span> <span class="o">*=</span>  <span class="mi">1</span><span class="n">j</span>        <span class="o">/</span> <span class="n">omega</span>
        
        <span class="k">return</span> <span class="n">vector</span>   </div>
    
<div class="viewcode-block" id="VarSSIRef.save_state"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.save_state">[docs]</a>    <span class="k">def</span> <span class="nf">save_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        
        
        <span class="n">dirname</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
        
        <span class="n">out_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;self.state&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">}</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.start_time&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># subspace matrices</span>
            
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.subspace_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_method</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_columns&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_columns</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_block_rows</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.num_blocks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_blocks</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.corr_mats_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_mats_mean</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.corr_matrices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_matrices</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.subspace_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.subspace_matrices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_matrices</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># state models and sensitivities</span>
            
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_order</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.state_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.output_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_matrix</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.O&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">O</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.U&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">U</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.S&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">S</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.V_T&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">V_T</span>
            
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.variance_algo&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.sigma_R&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">sigma_R</span> <span class="c1"># slow and covariance</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.S3&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">S3</span> <span class="c1"># slow and covariance</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.J_OHS3&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">J_OHS3</span> <span class="c1"># slow and covariance</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.sigma_H&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">sigma_H</span> <span class="c1"># slow and projection</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.J_OH&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">J_OH</span> <span class="c1"># slow and projection</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.hankel_cov_matrix&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">hankel_cov_matrix</span><span class="c1">#fast or projection</span>
                 
            
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.lsq_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lsq_method</span>    
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Q_nmax&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Q_nmax</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.R_nmax&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">R_nmax</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.S_nmax&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">S_nmax</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.J_Rnmax&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">J_Rnmax</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.J_Snmax&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">J_Snmax</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Q1&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Q1</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Q2&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Q2</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Q3&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Q3</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.J_OHT&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">J_OHT</span> <span class="c1">#fast    </span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>
                <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.Q4&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">Q4</span>
                            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1"># modal params </span>

            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.eigenvalues&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_frequencies</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modal_damping</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_shapes</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.std_frequencies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_frequencies</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.std_damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_damping</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;self.std_mode_shapes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_mode_shapes</span>
            
        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">out_dict</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data saved to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="VarSSIRef.load_state"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.load_state">[docs]</a>    <span class="nd">@classmethod</span> 
    <span class="k">def</span> <span class="nf">load_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">prep_data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Now loading previous results from  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        
        <span class="n">in_dict</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    

        <span class="k">if</span> <span class="s1">&#39;self.state&#39;</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
            <span class="n">state</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.state&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
    
<span class="c1">#         for this_state, state_string in zip(state, [&#39;Subspace Matrices Built&#39;,</span>
<span class="c1">#                                                     &#39;State Matrices and Sensitivities Computed&#39;,</span>
<span class="c1">#                                                     &#39;Modal Parameters Computed&#39;,</span>
<span class="c1">#                                                     ]):</span>
<span class="c1">#             if this_state: print(state_string)</span>
        
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prep_data</span><span class="p">,</span> <span class="n">PreprocessData</span><span class="p">)</span>
        <span class="n">setup_name</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.setup_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.start_time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">setup_name</span> <span class="o">==</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">setup_name</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        
        <span class="k">assert</span> <span class="n">start_time</span> <span class="o">==</span> <span class="n">prep_data</span><span class="o">.</span><span class="n">start_time</span>
        <span class="c1">#prep_data = in_dict[&#39;self.prep_data&#39;].item()</span>
        <span class="n">ssi_object</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">prep_data</span><span class="p">)</span>
        <span class="n">ssi_object</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1"># covariances</span>
            
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.subspace_method&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_columns</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_columns&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_block_rows&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_blocks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.num_blocks&#39;</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">corr_mats_mean</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.corr_mats_mean&#39;</span><span class="p">]</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">corr_matrices</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.corr_matrices&#39;</span><span class="p">]</span>                
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_matrix</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.subspace_matrix&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_matrices</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.subspace_matrices&#39;</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Subspace Matrices Built: </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1"> block_rows&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_method</span><span class="p">,</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">num_block_rows</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="c1"># state models</span>
            
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">max_model_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.max_model_order&#39;</span><span class="p">])</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">state_matrix</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.state_matrix&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">output_matrix</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.output_matrix&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">O</span> <span class="o">=</span>  <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.O&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">U</span> <span class="o">=</span>  <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.U&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span>  <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.S&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">V_T</span> <span class="o">=</span>  <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.V_T&#39;</span><span class="p">]</span>
            
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.variance_algo&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;covariance&#39;</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">sigma_R</span>  <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.sigma_R&#39;</span><span class="p">]</span> <span class="c1"># slow and covariance</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">S3</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.S3&#39;</span><span class="p">]</span> <span class="c1"># slow and covariance</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">J_OHS3</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.J_OHS3&#39;</span><span class="p">]</span> <span class="c1"># slow and covariance</span>
            <span class="k">if</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;slow&#39;</span> <span class="ow">and</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">sigma_H</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.sigma_H&#39;</span><span class="p">]</span> <span class="c1"># slow and projection</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">J_OH</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.J_OH&#39;</span><span class="p">]</span> <span class="c1"># slow and projection</span>
            <span class="k">if</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">or</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">subspace_method</span> <span class="o">==</span> <span class="s1">&#39;projection&#39;</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">hankel_cov_matrix</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.hankel_cov_matrix&#39;</span><span class="p">]</span><span class="c1">#fast or projection</span>
       
            
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.lsq_method&#39;</span><span class="p">])</span>    
            <span class="k">if</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">Q_nmax</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Q_nmax&#39;</span><span class="p">]</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">R_nmax</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.R_nmax&#39;</span><span class="p">]</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">S_nmax</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.S_nmax&#39;</span><span class="p">]</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">J_Rnmax</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.J_Rnmax&#39;</span><span class="p">]</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">J_Snmax</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.J_Snmax&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">and</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;pinv&#39;</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">Q1</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Q1&#39;</span><span class="p">]</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">Q2</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Q2&#39;</span><span class="p">]</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">Q3</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Q3&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="ow">and</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">lsq_method</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span>
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">J_OHT</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.J_OHT&#39;</span><span class="p">]</span> <span class="c1">#fast      </span>
            <span class="k">if</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">variance_algo</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span><span class="p">:</span>            
                <span class="n">ssi_object</span><span class="o">.</span><span class="n">Q4</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.Q4&#39;</span><span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;State Matrices and Sensitivities Computed: </span><span class="si">{}</span><span class="s1"> up to order </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ssi_object</span><span class="o">.</span><span class="n">lsq_method</span><span class="p">,</span> <span class="n">ssi_object</span><span class="o">.</span><span class="n">max_model_order</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="c1"># modal params</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.eigenvalues&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_frequencies</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_frequencies&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">modal_damping</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.modal_damping&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">mode_shapes</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.mode_shapes&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">std_frequencies</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.std_frequencies&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">std_damping</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.std_damping&#39;</span><span class="p">]</span>
            <span class="n">ssi_object</span><span class="o">.</span><span class="n">std_mode_shapes</span><span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="s1">&#39;self.std_mode_shapes&#39;</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Modal Parameters Computed&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ssi_object</span></div>
    
<div class="viewcode-block" id="VarSSIRef.rescale_mode_shape"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.VarSSIRef.rescale_mode_shape">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rescale_mode_shape</span><span class="p">(</span><span class="n">modeshape</span><span class="p">,</span> <span class="n">doehler_style</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1">#scaling of mode shape</span>
        <span class="k">if</span> <span class="n">doehler_style</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">modeshape</span><span class="p">))</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">modeshape</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">modeshape</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modeshape</span> <span class="o">=</span> <span class="n">modeshape</span> <span class="o">/</span> <span class="n">modeshape</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">modeshape</span><span class="p">))]</span>
            <span class="k">return</span> <span class="n">modeshape</span></div></div>
<span class="c1"># def update_svd():</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     A is the full matrix</span>
<span class="c1">#     r_l is the lower bound where to start the svd</span>
<span class="c1">#     that means all columns and rows above r are set to zero and the svd </span>
<span class="c1">#     is incrementally updated</span>
<span class="c1">#     in each step, first a column and then a row is added/updated</span>
<span class="c1">#     </span>
<span class="c1">#     the above procedure only works for low rank matrices where </span>
<span class="c1">#     r is approximately the sqrt of the first dimension</span>
<span class="c1">#         </span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     </span>
<span class="c1">#     </span>
<span class="c1">#     A= np.random.random((5,4))</span>
<span class="c1">#     B=np.copy(A)</span>
<span class="c1">#     </span>
<span class="c1">#     r=A.shape[1]-1</span>
<span class="c1">#     B[:,r:]=0</span>
<span class="c1">#     </span>
<span class="c1">#     U,S,V_T = np.linalg.svd(B,0)    </span>
<span class="c1">#     U_,S_,V_T_ = update_column(U[:,:r],S[:r],V_T[:r,:],A[:,r])</span>
<span class="c1">#     </span>
<span class="c1">#     oU,oS,oV_T = np.linalg.svd(A,0)</span>
<span class="c1">#     print(np.allclose(np.abs(oU),np.abs(U_)))</span>
<span class="c1">#     print(np.allclose(np.abs(oS),np.abs(S_)))</span>
<span class="c1">#     print(np.allclose(np.abs(oV_T),np.abs(V_T_)))    </span>
<span class="c1">#     print(np.allclose(A,oU.dot(np.diag(S_)).dot(oV_T)))</span>
<span class="c1">#     print(&#39;&#39;,A,&#39;\n&#39;,U_.dot(np.diag(S_)).dot(V_T_))</span>
<span class="c1">#     </span>
<span class="c1"># </span>
<span class="c1"># def update_column(U,S,V_T,y,r):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     updates column r in the matrix formed by U.dot(np.diag(s)).dot(V_T) </span>
<span class="c1">#     to the provided column y</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     col_num = V_T.shape[1]</span>
<span class="c1">#     b=np.zeros((col_num,1))</span>
<span class="c1">#     b[-1]=1</span>
<span class="c1">#     a = np.expand_dims(y,1)</span>
<span class="c1">#     m = U.T.dot(a)</span>
<span class="c1">#     p_ = a - U.dot(m)</span>
<span class="c1">#     p = np.sqrt(a.T.dot(p_))</span>
<span class="c1">#     P = p/p_</span>
<span class="c1">#     mat = np.vstack([np.hstack([np.diag(S),m]),np.expand_dims(np.append(np.zeros_like(S),p),0)])</span>
<span class="c1">#     </span>
<span class="c1">#     U_,S_,V_T_ = np.linalg.svd(mat,0)</span>
<span class="c1">#     U__ = np.hstack((U,P)).dot(U_)</span>
<span class="c1">#     V_T__ = np.hstack((V_T.T,b)).dot(V_T_.T).T</span>
<span class="c1">#     return U__,S_,V_T__</span>
<span class="c1">#     </span>
    
<div class="viewcode-block" id="main"><a class="viewcode-back" href="../classes/VarSSIRef.html#VarSSIRef.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1">#update_svd()</span>
    <span class="c1">#exit()</span>
    <span class="n">permutation</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1">#test decompositions derived from the qr decomposition</span>
    <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">1024</span><span class="p">,</span><span class="mi">3072</span><span class="p">))</span>
    <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">T</span>
    <span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="n">rq_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
    <span class="n">q</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="n">ql_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">)))</span>
    <span class="n">l</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">lq_decomp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">l</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
    
    <span class="k">pass</span></div>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1">#pass</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Simon Marwitz, Volkmar Zabel, Andrei Udrea.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>